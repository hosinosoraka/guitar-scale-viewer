<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Scales and Fretboard Editor Ver 2.1.3</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root{
      /* Dark (default) palette */
      --bg:#0f1115; --panel:#171a21; --ink:#e6e6e6; --muted:#9aa4b2; --accent:#4f8cff;
      --board1:#1b222d; --board2:#121821; --nut:#e2e8f0; --fret:#293042; --string:#d1d7e1;
      --pos-border:#ffffff;  /* ダーク時のポジション縁：白 */
      --label-ink:#000000;   /* 円内の文字色 */
      --deg-root:#3b82f6; --deg-third:#22c55e; --deg-fifth:#ef4444; --deg-seventh:#ec4899; --deg-other:#32d296; --deg-blues:#ffd166;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height:1.5; display:flex; flex-direction:column; min-height:100vh;
    }
    header{
      padding:12px 16px; border-bottom:1px solid #232735;
      background:linear-gradient(180deg, rgba(21,24,35,.85), rgba(20,23,32,.85));
    }
/* 共通の .toolbar はデフォルト最小限（プリセットなど他所は今まで通り） */
.toolbar{
  display:grid; gap:10px;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  align-items:end; max-width:90vw; margin:0 auto;
}

/* ▼ 上段（ヘッダー）のツールバーだけを “左詰め・収縮” にする */
.toolbar.toolbar--main{
  /* 列の自動生成を「中身に合わせて詰める」モードに */
  grid-template-columns: none;
  grid-auto-flow: column;
  grid-auto-columns: max-content;
}

/* 上段だけはコントロールの 100% 幅を解除してコンテンツ幅に */
.toolbar.toolbar--main select,
.toolbar.toolbar--main button,
.toolbar.toolbar--main input[type="text"]{
  width: auto;
}

/* 1列目（キー）と2列目（スケール）の最小/最大幅は上段だけに適用 */
.toolbar.toolbar--main > div:first-child{  /* キー */
  max-width: 96px;   /* #keySelect (88〜96px) と整合 */
}
.toolbar.toolbar--main > div:nth-child(2){ /* スケール */
  min-width: 140px;
}
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type="text"], select, button{
      width:100%; padding:10px 12px; border-radius:12px;
      border:1px solid #2a2f40; background:var(--panel); color:var(--ink); outline:none;
    }
    select:focus, button:focus, input[type="text"]:focus { border-color: var(--accent); }

    /* --- ここから追記 --- */

    /* 1) キーのセレクト幅を圧縮して、右側ボタンの折返しを防止 */
    #keySelect{
      width: 88px;      /* 目安：現状の約1/2。必要に応じて 80–96px で微調整 */
      min-width: 80px;
    }

    /* 2) 上段の「全表示」「全消去」「コピー」を折り返さない＋最小幅を確保 */
    #btnShowAllMain,
    #btnHideAllMain,
    #btnCopyMain{
      white-space: nowrap;   /* 折返し防止 */
    }
    #btnShowAllMain,
    #btnHideAllMain{
      min-width: 84px;       /* 日本語2語の折返し防止 */
    }
    #btnCopyMain{
      min-width: 68px;       /* 「コピー」の最小幅 */
    }
    /* --- 追記ここまで --- */
    main{ padding:16px; display:grid; place-items:center; }
    .card{
      width:100%; max-width:90vw; background:var(--panel);
      border:1px solid #232735; border-radius:12px; padding:12px; margin-bottom:12px;
    }

    canvas{ width:100%; height:360px; display:block; border-radius:12px; background:transparent; }

    .legend{ display:flex; gap:8px; flex-wrap:wrap; font-size:12px; color:var(--muted); padding-top:8px; }
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid #2a2f40; background:var(--panel); }
    .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    .foot { color:var(--muted); text-align:center; font-size:12px; margin-top:8px; }

    .positions{ width:100%; max-width:90vw; margin:0 auto; display:flex; flex-direction:column; gap:12px; }
    .pos-card{ background:var(--panel); border:1px solid #232735; border-radius:12px; padding:12px; }
    .pos-title{ font-size:12px; color:var(--muted); margin:4px 0 8px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .pos-name{ color:var(--ink); font-weight:600; outline: none; padding: 2px 6px; border-radius: 8px; }
    .pos-name:focus{ box-shadow: 0 0 0 2px rgba(79,140,255,0.35); background: rgba(79,140,255,0.08); }
    .pos-canvas{ width:100%; height:360px; display:block; border-radius:12px; }
.pos-actions{ display:flex; gap:8px; }

/* 下段アクションボタンの折返し方針 */
.pos-actions { flex-wrap: wrap; }   /* モバイル等は折返し許容 */
@media (min-width: 768px){
  .pos-actions { flex-wrap: nowrap; }  /* PC幅では横一列に */
}

/* 下段アクションボタンの折返し防止（必要な場合のみ） */
.pos-actions { flex-wrap: wrap; } /* 折返し許容なら wrap のまま */
@media (min-width: 768px){
  .pos-actions { flex-wrap: nowrap; }
}

.icon-btn{ border:1px solid #2a2f40; background:transparent; color:var(--ink); padding:6px 10px; border-radius:10px; cursor:pointer; }

/* 下段アクションのうち「SHIFT / ペースト」は折り返し禁止＋最小幅を拡張 */
.pos-actions .btnShiftOne,
.pos-actions .btnPasteBoard{
  white-space: nowrap;   /* ← ボタン内の改行を抑止 */
  min-width: 108px;      /* ← 少し広げる（100〜120の範囲でお好みで） */
}

/* 「全表示」「全消去」「コピー」は今のままでもOKだが、気になるようなら最小幅を少し確保 */
.pos-actions .btnShowAll{ min-width: 76px; }
.pos-actions .btnHideAll{ min-width: 76px; }
.pos-actions .btnCopyBoard{ min-width: 76px; }
    .icon-btn:hover{ border-color:var(--accent); }

    details.dropdown{ border:1px solid #2a2f40; border-radius:12px; background:var(--panel); overflow:hidden; }
details.dropdown > summary{
  list-style: none;
  cursor: pointer;
  padding: 10px 12px;
  border-radius: 12px;
  outline: none;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: space-between; /* ← タイトルと「▾」が左右にきれいに配置される */
  width: 100%;                    /* ← クリック範囲がカード幅いっぱいになる */
}
    details.dropdown[open] > summary{ border-bottom:1px solid #2a2f40; border-bottom-left-radius:0; border-bottom-right-radius:0; }
    details.dropdown .menu{ max-height:320px; overflow:auto; padding:4px 0; }
    .preset-item{ display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border-bottom:1px solid #232735; cursor:pointer; }
    .preset-item:last-child{ border-bottom:none; }
    .preset-item:hover{ background: rgba(255,255,255,0.04); }
    .preset-item.dragging{ opacity:0.5; }
    .preset-meta{ flex:1; min-width:0; }
    .preset-name{ font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .preset-sub{ font-size:11px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .row-actions{ display:flex; gap:8px; }
    .empty{ color:var(--muted); padding:12px; font-size:13px; }
    .notice{ color:#9aa4b2; font-size:12px; margin-top:8px; }

/* === 横長で小さい +1 / -1 ボタン用（※posShift用は小さいまま） === */
#btnPosShiftDown,
#btnPosShiftUp {
  width: auto;
  padding: 4px 14px;
}

/* === ツールバーに並ぶボタンの高さを揃える（キー/スケール/PDF などと同じ） === */
#btnToggleChordTones,
#btnToggleDragErase {
  width: 100%;
  padding: 10px 12px;  /* 他ボタンと同じ */
}




  </style>

<style id="preset-tweaks">

  /* プリセット名の下のサブ情報を完全に非表示 */
  .preset-sub{ display:none !important; }

  /* リスト行をスリムに */
  .preset-item{
    display:flex;            /* もし既存でflexならこの指定は重複OK */
    align-items:center;
    justify-content:space-between;
    padding: 6px 10px;       /* ← 上下を小さく */
    gap: 8px;
  }
  .preset-meta .preset-name{
    line-height: 1.2;        /* 行の背を低く */
    margin: 0;
  }

/* 右側ボタン（読み込む／ゴミ箱）を横長・低背に */
.row-actions{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;              /* ← 行を折り返さない */
}

.row-actions .icon-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:4px 12px;              /* 横は少し長め、縦は薄く */
  height:28px;                   /* 行の背を下げる */
  line-height:1;
  font-size:12px;
  border-radius:6px;
  white-space:nowrap;            /* ← ボタン内の文字折り返し禁止 */
}

/* 「読み込む」だけ少しワイドにして折り返し防止 */
.row-actions .icon-btn:first-child{
  min-width:96px;                /* 環境次第で 88〜110px で調整 */
  padding-inline:14px;
}

/* ゴミ箱はコンパクトのまま */
.row-actions .icon-btn[title="削除"]{
  min-width:0;
  padding-inline:8px;
}

</style>
<meta name="google-site-verification" content="bvkaJrhr4P2Lj8VCOsCaoOTBEPPGFsQXAtq2BYEdC9I" />
</head>
<body>
<header>
  <div class="toolbar toolbar--main">
    <div>
      <label for="keySelect">キー</label>
      <select id="keySelect"></select>
    </div>
    <div>
      <label for="scaleSelect">スケール</label>
      <select id="scaleSelect"></select>
    </div>
    <div>
      <label for="labelMode">ラベル表示</label>
      <select id="labelMode">
        <option value="note">音名</option>
        <option value="degree">度数</option>
        <option value="both" selected>両方</option>
      </select>
    </div>
    
    <!-- ▼ 追加：♯/♭ の表記切替 -->
    <div>
      <label for="accidentalMode">表記</label>
      <select id="accidentalMode">
        <option value="sharp">♯</option>
        <option value="flat" selected>♭</option>
      </select>
    </div>
<div>
      <label for="fretCount">フレット数（12〜24）</label>
      <select id="fretCount"></select>
    </div>
    <div>
      <label>&nbsp;</label>
      <button id="btnToggleChordTones">コードトーンのみ表示</button>
    </div>
    <!-- ▼ 追加：コードトーンの“直下”にドラッグ消しゴムボタンを配置 -->
    <div>
      <label>&nbsp;</label>
      <button id="btnToggleDragErase" title="マウス/タッチでなぞって非表示（ショートカット: E）">ドラッグ消しゴム：OFF</button>
    </div>
    <div>
      <label>&nbsp;</label>
      <button id="btnExportPdf">PDFで保存</button>
    </div>
    <div>
      <label>&nbsp;</label>
      <div style="display:flex; gap:8px;">
        <button id="btnShowAllMain">全表示</button>
        <button id="btnHideAllMain">全消去</button>
        <button id="btnCopyMain">コピー</button>
      </div>
    </div>


  </div>
</header>


<main>
<!-- 上段：全体指板 -->
<div class="card">
  <canvas id="fretboard" width="1400" height="520"></canvas>
  <div class="legend" id="legend"></div>
  <div class="foot">
    クリックでポジションの非表示/再表示（上段/下段ともに）
    <br>
    <br><b><font size="4" color=#00FF00>Ver 2.0.0になりました。多くの改善がされてますので詳しくはReadMeを一読ください。</font></B>
    <br>Ver 2.0.7へのバージョンアップに伴い、JSONやプリセットが乱れて表示される場合がございます。ご了承ください。
    <br>
    <br> Ver 2.0.2 プリセットの順番をドラッグで入れ替えられるようになりました。
    <br> Ver 2.0.3 Bug Bixed
    <br> Ver 2.0.4 JSONファイルのリンクを追加
    <br> Ver 2.0.5 Bug Bixed
    <br> Ver 2.0.6 スケール追加、及び、名称とリストの最適化
    <br> Ver 2.0.7 プリセット、及びJSONの保存と読み込みの最適化。
    <br> Ver 2.0.8 Bug Bixed
    <br> Ver 2.0.9 Bug Bixed
    <br> Ver 2.1.0 音名の#とbを切り替えられるようになりました。
    <br> Ver 2.1.1 クリックで表示非表示したポジションがPDFのに反映されないバグを修正しました。
    <br> Ver 2.1.2 #とbの表記を個別に設定できるように変更。
    <br>           既存のプリセットやJSONが正常に読み込めない場合があります。
    <br> Ver 2.1.3 SHIFT機能のバグを修正。

  </div>
  <div style="text-align:center; margin-top:6px;">
    <a href="https://github.com/hosinosoraka/guitar-scale-viewer/blob/main/README.md"
       target="_blank" rel="noopener"
       style="color:yellow; font-weight:bold; text-decoration:none;">
       ReadMe
    </a>
  </div>

<div style="text-align:center; margin-top:6px;">
  <a href="https://github.com/hosinosoraka/guitar-scale-viewer/tree/main/JSON"
     target="_blank" rel="noopener"
     style="color:yellow; font-weight:bold; text-decoration:none;">
     作者が作成したJSONのダウンロードはこちら（随時追加します）
  </a>
</div>

</div>

  <!-- プリセット保存/読み込み -->
  <div class="card">
    <div class="toolbar" style="grid-template-columns: 1fr 1fr; padding:0; max-width:unset;">
      <div>
        <label for="presetName">プリセット名</label>
        <input id="presetName" type="text" list="presetNames" placeholder="例）Cメジャー_7ポジ_v1" />
        <datalist id="presetNames"></datalist>
        <div class="notice">同名で保存すると上書きします（キー/スケール/フレット/ラベル表示/各キャンバスの非表示/ポジション名を保存）。</div>
      </div>
      <div>
        <label>&nbsp;</label>
        <div style="display:flex; gap:8px;">
          <button id="btnSavePreset">この状態を保存</button>
          <button id="btnExportPreset">JSONを書き出し</button>
          <button id="btnImportPreset">JSONを読み込み</button>
          <input id="importFile" type="file" accept=".json,application/json" style="display:none;">
        </div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <details id="presetDropdown" class="dropdown">
        <summary>ローカル保存済みプリセット ▾</summary>
        <div id="presetList" class="menu"><div class="empty">（保存されたプリセットはありません）</div></div>
      </details>
    </div>

    <div class="notice" id="presetMeta"></div>
  </div>




  <!-- 下段：8ポジション（名前は編集可） -->
  <section class="positions" id="positions">

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-I" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-6-I" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-6-I" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-6-I" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-6-I" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-6-I" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-6-I" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-6-I" class="icon-btn btnAccToggle">表記: ♭</button>
</div>

      </div>
      <canvas class="pos-canvas" id="pos-6-I"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-M" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-6-M" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-6-M" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-6-M" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-6-M" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-6-M" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-6-M" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-6-M" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-6-M"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-P" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-6-P" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-6-P" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-6-P" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-6-P" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-6-P" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-6-P" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-6-P" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-6-P"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-5-I" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-5-I" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-5-I" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-5-I" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-5-I" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-5-I" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-5-I" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-5-I" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-5-I"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-5-M" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-5-M" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-5-M" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-5-M" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-5-M" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-5-M" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-5-M" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-5-M" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-5-M"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-5-P" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-5-P" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-5-P" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-5-P" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-5-P" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-5-P" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-5-P" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-5-P" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-5-P"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-4-I" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-4-I" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-4-I" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-4-I" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-4-I" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-4-I" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-4-I" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-4-I" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-4-I"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-4-M" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-4-M" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-4-M" data-delta="1" class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-4-M" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-4-M" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-4-M" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-4-M" class="icon-btn btnPasteBoard">ペースト</button>
  <button data-pos="pos-4-M" class="icon-btn btnAccToggle">表記: ♭</button>
</div>
      </div>
      <canvas class="pos-canvas" id="pos-4-M"></canvas>
    </div>

  </section>

</main>

<script>
/* ===== 基本設定 ===== */
  const STRINGS = 6;
  const NOTE_RADIUS = 18;  // PC
  const INLAY_R = 5.5, INLAY_R_12 = 6.5;
  const LABEL_OFFSET_FACTOR = 0.42;
  function getNoteRadius(){ return (window.innerWidth <= 768) ? NOTE_RADIUS * 0.7 : NOTE_RADIUS; }
  let dpr = 1; function syncDPR(){ dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1)); }

  /* デフォルトのポジション名 */
  const POSITION_IDS = ['pos-6-I','pos-6-M','pos-6-P','pos-5-I','pos-5-M','pos-5-P','pos-4-I','pos-4-M'];
  
  // 各ポジション専用の表記(♯/♭)モードを保持（初期は現在のグローバル accidentalMode）
  const BOARD_ACCIDENTAL = {};
  POSITION_IDS.forEach(id => { BOARD_ACCIDENTAL[id] = (typeof globalThis.accidentalMode === 'string' ? globalThis.accidentalMode : 'flat'); });
const DEFAULT_TITLES = {
    'pos-6-I':'タイトル１ クリックで変更できます。（例　Ｃメジャースケール）等',
    'pos-6-M':'タイトル２ （例　6弦スタート｜人差し指）等',
    'pos-6-P':'タイトル３',
    'pos-5-I':'タイトル４',
    'pos-5-M':'タイトル５',
    'pos-5-P':'タイトル６',
    'pos-4-I':'タイトル７',
    'pos-4-M':'タイトル８',
  };

  /* 下段ボードの独立状態（キー／スケール） */
  const BOARD_STATE = {};
  POSITION_IDS.forEach(id => {
    // 初期状態はChromatic Scale (All Notes)n（キーは C で固定）
    BOARD_STATE[id] = { key: 'C', scale: 'Chromatic Scale (All Notes)' };
  });

  function getBoardKey(id){ return (BOARD_STATE[id] && BOARD_STATE[id].key) || 'C'; }
  function getBoardScale(id){ return (BOARD_STATE[id] && BOARD_STATE[id].scale) || 'Chromatic Scale (All Notes)'; }
  function setBoardKey(id, key){ if (BOARD_STATE[id]) BOARD_STATE[id].key = key; }
  function setBoardScale(id, scale){ if (BOARD_STATE[id]) BOARD_STATE[id].scale = scale; }




  /* 音名・スケール */
  const N_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const N_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
  const KEYS    = [...N_SHARP];
// === 表記モード（♯ / ♭） ===
let accidentalMode = 'flat'; // 'sharp' | 'flat'

function getNoteNames(){
  return (accidentalMode === 'flat') ? N_FLAT : N_SHARP;
}
function getKeyList(){
  return getNoteNames();
}
// 名前を現在表記へ変換（C#↔Db など）
function getNoteListIndexSafe(name){
  const i1 = N_SHARP.indexOf(name); if (i1 >= 0) return i1;
  const i2 = N_FLAT.indexOf(name);  if (i2 >= 0) return i2;
  return -1;
}
function toCurrentSpelling(name){
  let idx = getNoteListIndexSafe(name);
  if (idx < 0) idx = 0;
  return getNoteNames()[idx];
}

  const SCALES = {

    // --- 全表示 ---
    "Chromatic Scale (All Notes)": { intervals:[0,1,2,3,4,5,6,7,8,9,10,11], degrees:["1","b9th","9th","m3","3","11th","b5/#11","5","b13","13th","m7","7"] },
    // --- Major 系 ---
    "Major (Ionian)": { intervals:[0,2,4,5,7,9,11], degrees:["1","9th","3","11th","5","13th","7"] },
    "Dorian":           { intervals:[0,2,3,5,7,9,10], degrees:["1","9th","m3","11th","5","13th","m7"] },
    "Phrygian":         { intervals:[0,1,3,5,7,8,10], degrees:["1","b9th","m3","11th","5","b13th","m7"] },
    "Lydian":           { intervals:[0,2,4,6,7,9,11], degrees:["1","9th","3","#11th","5","13th","7"] },
    "Mixolydian":       { intervals:[0,2,4,5,7,9,10], degrees:["1","9th","3","11th","5","13th","m7"] },
    "Natural Minor (Aeolian)": { intervals:[0,2,3,5,7,8,10], degrees:["1","9th","m3","11th","5","b13th","m7"] },
    "Locrian":          { intervals:[0,1,3,5,6,8,10], degrees:["1","b9th","m3","11th","b5","b13th","m7"] },

    // --- Melodic Minor 系 ---
    "Melodic Minor":  { intervals:[0,2,3,5,7,9,11], degrees:["1","9th","m3","11th","5","13th","7"] },
    "Dorian b2":        { intervals:[0,1,3,5,7,9,10], degrees:["1","b9th","m3","11th","5","13th","m7"] },
    "Lydian #5 (Lydian Augmented)":        { intervals:[0,2,4,6,8,9,11], degrees:["1","9th","3","#11th","#5","13th","7"] },
    "Lydian b7 (Lydian Dominant)":        { intervals:[0,2,4,6,7,9,10], degrees:["1","9th","3","#11th","5","13th","m7"] },
    "Mixolydian b6":   { intervals:[0,2,4,5,7,8,10], degrees:["1","9th","3","11th","5","b13th","m7"] },
    "Aeolian b5":       { intervals:[0,2,3,5,6,8,10], degrees:["1","9th","m3","11th","b5","b13th","m7"] },
    "Altered Scale (Super Locrian)": { intervals:[0,1,3,4,6,8,10], degrees:["1","b9th","#9th","3","#11th","b13th","m7"] },

    // --- Harmonic Minor 系 ---
    "Harmonic Minor": {   intervals:[0,2,3,5,7,8,11],   degrees:["1","9th","m3","11th","5","b13th","7"] },
    "Locrian natural 6": {   intervals:[0,1,3,5,6,9,10],   degrees:["1","b9th","m3","11th","b5","13th","m7"] },
    "Ionian #5": {   intervals:[0,2,4,5,8,9,11],   degrees:["1","9th","3","11th","#5","13th","7"] },
    "Dorian #4": {   intervals:[0,2,3,6,7,9,10],   degrees:["1","9th","m3","#11th","5","13th","m7"] },
    "Mixolydian b9 b13 (HP5)": {   intervals:[0,1,4,5,7,8,10],   degrees:["1","b9th","3","11th","5","b13th","m7"] },
    "Lydian #2": {   intervals:[0,3,4,6,7,9,11],   degrees:["1","#9th","3","#11th","5","13th","7"]  },
    "Altered Dominant bb7 (Super Locrian)": {   intervals:[0,1,3,4,6,8,9],    degrees:["1","b9th","#9th","3","b5","b13th","bb7"] },

    // --- Diminished ---
    "Combination Diminished (Half–Whole)": { intervals:[0,1,3,4,6,7,9,10], degrees:["1","b9th","#9th","3","b5","5","13th","m7"] },
    "Diminished (Whole–Half)":             { intervals:[0,2,3,5,6,8,9,11], degrees:["1","9th","#9th","11th","b5","b13th","13th","7"] },

    // --- Symmetric (Augmented) ---
    "Augmented Scale":       { intervals:[0,3,4,7,8,11], degrees:["1","m3","3","5","b13th","7"] },

    // --- Pentatonic / Blues ---
    "Major Pentatonic": { intervals:[0,2,4,7,9],    degrees:["1","9th","3","5","13th"] },
    "Minor Pentatonic": { intervals:[0,3,5,7,10],   degrees:["1","m3","11th","5","m7"] },
    "Major Blues Scale": { intervals:[0,2,3,4,7,9], degrees:["1","9th","m3","3","5","13th"] },
    "Minor Blues Scale": { intervals:[0,3,5,6,7,10], degrees:["1","m3","11th","b5","5","m7"] },

    // --- Additional Pentatonic Variants ---
    "Dorian Pentatonic":     { intervals:[0,2,3,7,10], degrees:["1","9th","m3","5","m7"] },
    "Mixolydian Pentatonic": { intervals:[0,2,4,7,10], degrees:["1","9th","3","5","m7"] },

    // --- Jazz Oriented ---
    "Harmonic Major":       { intervals:[0,2,4,5,7,8,11], degrees:["1","9th","3","11th","5","b13th","7"] },
    "Double Harmonic Major":{ intervals:[0,1,4,5,7,8,11], degrees:["1","b9th","3","11th","5","b13th","7"] },
    "Whole Tone Scale":     { intervals:[0,2,4,6,8,10],   degrees:["1","9th","3","#11th","#5","m7"] },
    "Enigmatic Scale":      { intervals:[0,1,4,6,8,10,11],degrees:["1","b9th","3","#11th","#5","m7","7"] },

    // --- Bebop Scales ---
    "Bebop Major Scale":     { intervals:[0,2,4,5,7,8,9,11],  degrees:["1","9th","3","11th","5","#5","13th","7"] },
    "Bebop Dominant Scale":  { intervals:[0,2,4,5,7,9,10,11], degrees:["1","9th","3","11th","5","13th","m7","7"] },
    "Bebop Minor Scale":     { intervals:[0,2,3,5,7,9,10,11], degrees:["1","9th","m3","11th","5","13th","m7","7"] },

    // --- World Scales ---
    "Hungarian Minor":       { intervals:[0,2,3,6,7,8,11], degrees:["1","9th","m3","#11th","5","b13th","7"] },
    "Neapolitan Minor":      { intervals:[0,1,3,5,7,8,11], degrees:["1","b9th","m3","11th","5","b13th","7"] },
    "Neapolitan Major":      { intervals:[0,1,3,5,7,9,11], degrees:["1","b9th","m3","11th","5","13th","7"] },
    "Persian Scale":           { intervals:[0,1,4,5,6,8,11], degrees:["1","b9th","3","11th","b5","b13th","7"] },
    "Arabian Scale":           { intervals:[0,2,4,5,6,8,10], degrees:["1","9th","3","11th","b5","b13th","m7"] },
    "Raga Todi":               { intervals:[0,1,3,6,7,8,11], degrees:["1","b9th","m3","#11th","5","b13th","7"] },
    "Japanese Scale (In Sen)": { intervals:[0,1,5,7,10], degrees:["1","b9th","11th","5","m7"] },
    "Japanese Scale (In)":     { intervals:[0,1,5,7,8],  degrees:["1","b9th","11th","5","b13th"] },
    "Japanese Scale (Yo)":     { intervals:[0,2,5,7,9],  degrees:["1","9th","11th","5","13th"] },

  };

  
// === Scale select grouping (optgroup) ===
const SCALE_GROUPS = {
  "Utility": [
    "Chromatic Scale (All Notes)"
  ],

  "Major (Diatonic Modes)": [
    "Major (Ionian)", "Dorian", "Phrygian", "Lydian",
    "Mixolydian", "Natural Minor (Aeolian)", "Locrian"
  ],

  "Melodic Minor Modes": [
    "Melodic Minor", "Dorian b2",
    "Lydian #5 (Lydian Augmented)",
    "Lydian b7 (Lydian Dominant)",
    "Mixolydian b6", "Aeolian b5",
    "Altered Scale (Super Locrian)"
  ],

  "Harmonic Minor Modes": [
    "Harmonic Minor", "Locrian natural 6",
    "Ionian #5", "Dorian #4",
    "Mixolydian b9 b13 (HP5)",
    "Lydian #2",
    "Altered Dominant bb7 (Super Locrian)"
  ],

  "Symmetric (Diminished)": [
    "Combination Diminished (Half–Whole)",
    "Diminished (Whole–Half)"
  ],

  "Symmetric (Augmented)": [
    "Augmented Scale"
  ],

  "Pentatonic / Blues": [
    "Major Pentatonic", "Minor Pentatonic",
    "Major Blues Scale", "Minor Blues Scale",
    "Dorian Pentatonic", "Mixolydian Pentatonic"
  ],

  "Jazz Oriented": [
    "Harmonic Major", "Double Harmonic Major",
    "Whole Tone Scale", "Enigmatic Scale",
    "Bebop Major Scale", "Bebop Dominant Scale", "Bebop Minor Scale"
  ],

  "World Scales": [
    "Hungarian Minor", "Neapolitan Minor", "Neapolitan Major",
    "Persian Scale", "Arabian Scale", "Raga Todi",
    "Japanese Scale (In Sen)", "Japanese Scale (In)", "Japanese Scale (Yo)"
  ]
};



  // スケールセレクトを構築
  function populateScaleSelect(scaleSel, groups = SCALE_GROUPS){
    if (!scaleSel) return;
    scaleSel.innerHTML = '';
    for (const [label, keys] of Object.entries(groups)){
      const og = document.createElement('optgroup');
      og.label = label;
      keys.forEach(key => {
        const opt = document.createElement('option');
        opt.value = key;   // 内部値はSCALESのキー
        opt.textContent = key; // 表示もキー名そのまま
        og.appendChild(opt);
      });
      scaleSel.appendChild(og);
    }
  }
const TUNING = ["E","B","G","D","A","E"]; // 1弦→6弦

  /* ===== DOM ===== */
  const keySel = document.getElementById('keySelect');
  const scaleSel = document.getElementById('scaleSelect');
  const labelModeSel = document.getElementById('labelMode');
  const fretSel = document.getElementById('fretCount');
  const resetHiddenMain = document.getElementById('resetHiddenMain');
  const mainCanvas = document.getElementById('fretboard');
  const mainCtx = mainCanvas.getContext('2d');
  const accidentalSel = document.getElementById('accidentalMode');

  function remapAllKeysToCurrentSpelling(){
    // メイン
    const currentMain = keySel.value;
    const pc = getNoteListIndexSafe(currentMain);
    populateKeySelect();
    keySel.value = (pc >= 0 ? getNoteNames()[pc] : getNoteNames()[0]);
    // 下段8ボード
    POSITION_IDS.forEach(id => {
      const cur = getBoardKey(id);
      setBoardKey(id, toCurrentSpelling(cur));
    });
  }

  accidentalSel?.addEventListener('change', (e)=>{
    accidentalMode = e.target.value === 'flat' ? 'flat' : 'sharp';
    remapAllKeysToCurrentSpelling();
    autoHideOutOfScaleMain();
    rebuildMainHiddenFromLayers();
    drawAll();
  });


  const presetNameInput = document.getElementById('presetName');
  const presetNamesDatalist = document.getElementById('presetNames');
  const presetDropdown = document.getElementById('presetDropdown');
  const presetList = document.getElementById('presetList');
  const presetMeta = document.getElementById('presetMeta');
  const btnSavePreset = document.getElementById('btnSavePreset');
  const btnExportPreset = document.getElementById('btnExportPreset');
  const btnImportPreset = document.getElementById('btnImportPreset');
  const importFile = document.getElementById('importFile');
  // ▼ 7ポジ 横シフト：hiddenMap の座標を ±1 ずらし、キーも ±1 変更

function shiftPositionsMask(delta){
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
  POSITION_IDS.forEach(id => {
    const src = hiddenMap[id];
    const dst = new Set();
    if (!src) return;

    // 既存の非表示マスクを ±1 フレットに平行移動
    src.forEach(key => {
      const m = /^(\d+):(\d+)$/.exec(key);
      if(!m) return;
      const s = parseInt(m[1], 10);
      const f2 = parseInt(m[2], 10) + delta;
      if (f2 < 0 || f2 > frets) return; // 範囲外は捨てる
      dst.add(`${s}:${f2}`);
    });

    // ★ 新しく入ってくる端の列を最初から「非表示」に追加
    if (delta !== 0){
      const enteringFret = (delta > 0) ? 0 : frets; // +1なら0F、-1なら最終Fが“新規入場”
      for (let s = 0; s < STRINGS; s++){
        dst.add(`${s}:${enteringFret}`);
      }
    }

    hiddenMap[id] = dst;
  });
}

  
function stepKey(delta){
  const list = getKeyList();
  let idx = list.indexOf(keySel.value);
  if (idx < 0) idx = 0;
  keySel.value = list[(idx + delta + 12) % 12];
}

  function onPosShift(delta){
    shiftPositionsMask(delta); // シェイプを物理的に1フレット移動
    stepKey(delta);            // UIのキーも ±1 進める
    drawAll();                 // リセットはしない（隠し状態維持）
  }
  document.getElementById('btnPosShiftUp')?.addEventListener('click', ()=> onPosShift(+1));
  document.getElementById('btnPosShiftDown')?.addEventListener('click', ()=> onPosShift(-1));

// コードトーントグル（メインのみ再描画する）
const btnToggleChord = document.getElementById('btnToggleChordTones');
btnToggleChord?.addEventListener('click', () => {
  chordTonesOnly = !chordTonesOnly;
  btnToggleChord.textContent = chordTonesOnly ? 'コードトーン再表示' : 'コードトーンのみ表示';
  // 下段8ボードは影響させない：メインのみ再描画
  autoHideOutOfScaleMain(); rebuildMainHiddenFromLayers(); drawMain();
});



  // 下段ポジション名の要素
  const posNameEls = {};
  document.querySelectorAll('.pos-name').forEach(el => { posNameEls[el.dataset.pos] = el; });

// セレクト初期化

function populateKeySelect(){
  keySel.innerHTML='';
  getKeyList().forEach(k=>{
    const o=document.createElement('option');
    o.value=o.textContent=k;
    keySel.appendChild(o);
  });
}
populateKeySelect();
populateScaleSelect
(scaleSel);
for (let f=12; f<=24; f++){ const o=document.createElement('option'); o.value=String(f); o.textContent=String(f); fretSel.appendChild(o); }

// ★ 起動直後は Chromatic Scale (All Notes) にする（メイン）
keySel.value = 'C';
scaleSel.value = 'Chromatic Scale (All Notes)';
fretSel.value = '24';


  // デフォルト名を反映
  function applyDefaultTitles(){
    Object.entries(DEFAULT_TITLES).forEach(([id, name])=>{
      if (posNameEls[id]) posNameEls[id].textContent = name;
    });
  }

  // 非表示セット（メインは空、下段は初期状態で「全ポジション非表示」）
  const hiddenMap = { main:new Set() }; POSITION_IDS.forEach(id=> hiddenMap[id]=new Set());
const pinnedVisibleMain = new Set();


const ruleHiddenMain = new Set();
const userHiddenMain = new Set();


function rebuildMainHiddenFromLayers(){
  const ruleMinusPinned = [];
  ruleHiddenMain.forEach(k => { if (!pinnedVisibleMain.has(k)) ruleMinusPinned.push(k); });
  hiddenMap.main = new Set([...ruleMinusPinned, ...userHiddenMain]);
}

// コピー＆ペースト用クリップボード
  let clipboardBoard = null;


  // 指定ボードの全マス（弦 × 0〜frets）を非表示にするヘルパ
  function hideAllPositionsForBoard(mapKey){
    const frets = Math.max(12, Math.min(24, parseInt((document.getElementById('fretCount')?.value)||'16')));
    const set = hiddenMap[mapKey];
    set.clear();
    for (let s = 0; s < STRINGS; s++){
      for (let f = 0; f <= frets; f++){
        set.add(`${s}:${f}`);
      }
    }
  }

  function resetBoardState(mapKey, {clearHidden=false, clearForced=false}={}){
    if (clearHidden) hiddenMap[mapKey]?.clear();
  }



  /* === コードトーン表示トグル === */
let chordTonesOnly = false;
function isChordToneInterval(interval){
  return interval === 0 || interval === 3 || interval === 4 || interval === 7 || interval === 10 || interval === 11;
}

// === スケール判定ユーティリティ（メイン用） ===
function isInScaleForMain(s, f){
  const keyName = keySel.value;
  const scaleName = scaleSel.value;
  const root = getKeyList().indexOf(keyName);
  const pcs = new Set((SCALES[scaleName] || SCALES['Chromatic Scale (All Notes)']).intervals.map(i => (root + i) % 12));
  const pc = (N_SHARP.indexOf(TUNING[s]) + f) % 12;
  return pcs.has(pc);
}
function isChordAllowedForMain(s, f){
  if (!chordTonesOnly) return true;
  const keyName = keySel.value;
  const root = getKeyList().indexOf(keyName);
  const pc = (N_SHARP.indexOf(TUNING[s]) + f) % 12;
  const interval = (pc - root + 12) % 12;
  return isChordToneInterval(interval);
}
function isVisibleByScaleRule_Main(s, f){
  return isInScaleForMain(s,f) && isChordAllowedForMain(s,f);
}

function autoHideOutOfScaleMain(){
  ruleHiddenMain.clear();
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
  for (let s=0; s<STRINGS; s++){
    for (let f=0; f<=frets; f++){
      const k = s + ":" + f;
      const shouldBeHidden = !isVisibleByScaleRule_Main(s,f);
      if (shouldBeHidden){
        if (!pinnedVisibleMain.has(k)) ruleHiddenMain.add(k);
      }
    }
  }
  // 再構築: 規定の隠す ∪ ユーザーの隠す
  rebuildMainHiddenFromLayers();
}
/* ===== 共通描画ユーティリティ ===== */
/* ===== 共通描画ユーティリティ ===== */
  const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  function styleSnapshot(){
    return {
      board1: css('--board1'), board2: css('--board2'),
      nut: css('--nut'), fret: css('--fret'), string: css('--string'),
      posBorder: css('--pos-border'), labelInk: css('--label-ink'),
      muted: css('--muted'),
      degRoot: css('--deg-root'), degThird: css('--deg-third'),
      degFifth: css('--deg-fifth'), degSeventh: css('--deg-seventh'),
      degOther: css('--deg-other'), degBlues: css('--deg-blues')
    };
  }
  function roundRect(ctx, x, y, w, h, r){
    if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
  }
  function degreeColor(i, S){
    if (i===0) return S.degRoot;
    if (i===3||i===4) return S.degThird;
    if (i===7) return S.degFifth;
    if (i===10||i===11) return S.degSeventh;
    if (i===6) return S.degBlues;
    return S.degOther;
  }
  function drawNote(ctx, cx, cy, r, pc, root, degreeText, mode, keyName, S, noteNamesOpt){
    const interval = (pc - root + 12) % 12;
    const fill = degreeColor(interval, S);
    const noteNames = noteNamesOpt || getNoteNames();
    const noteName = noteNames[pc];

    ctx.fillStyle = fill;
    ctx.strokeStyle = S.posBorder;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    ctx.fillStyle = S.labelInk;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

    if (mode === 'note'){
      ctx.font = "700 " + Math.round(r*0.75) + "px system-ui";
      ctx.fillText(noteName, cx, cy);
    } else if (mode === 'degree'){
      ctx.font = "700 " + Math.round(r*0.75) + "px system-ui";
      ctx.fillText(degreeText || '', cx, cy);
    } else {
      const dy = r * LABEL_OFFSET_FACTOR;
      ctx.font = "700 " + Math.round(r*0.68) + "px system-ui";
      ctx.fillText(degreeText || '', cx, cy - dy);
      ctx.font = "700 " + Math.round(r*0.68) + "px system-ui";
      ctx.fillText(noteName,       cx, cy + dy);
    }
  }
  function layoutOn(ctx, canvasEl, strings, frets, S){
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    ctx.clearRect(0,0,w,h);
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;

    const boardX = 20, boardW = w - 40;
    const R = 16;
    const grd = ctx.createLinearGradient(0, fbY, 0, fbY + fbH);
    grd.addColorStop(0, S.board1); grd.addColorStop(1, S.board2);
    ctx.fillStyle = grd;
    roundRect(ctx, boardX, fbY, boardW, fbH, R); ctx.fill();
    ctx.strokeStyle = '#1f2432'; ctx.lineWidth = 1; ctx.stroke();

    ctx.fillStyle = S.nut; ctx.fillRect(baseX - 10, fbY, 10, fbH);

    ctx.strokeStyle = S.fret; ctx.lineWidth = 2;
    for(let f=1; f<=frets; f++){
      const x = baseX + fbW * (f / frets);
      ctx.beginPath(); ctx.moveTo(x, fbY); ctx.lineTo(x, fbY + fbH); ctx.stroke();
    }

    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    ctx.fillStyle = S.muted; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
    const footY = fbY + fbH + 16; ctx.fillText('0', openCx, footY);
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      ctx.fillText(String(f), (prevX + thisX)/2, footY);
    }

    ctx.fillStyle = '#3b80ff66';
    [3,5,7,9,12,15,17,19,21,24].forEach(f=>{
      if (f>frets) return;
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      const xCenter = (prevX + thisX) / 2;
      if (f%12===0){
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.33, INLAY_R_12, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.66, INLAY_R_12, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.5, INLAY_R, 0, Math.PI*2); ctx.fill();
      }
    });

    for(let s=0; s<strings; s++){
      const y = fbY + fbH * (s+0.5)/strings;
      ctx.strokeStyle = S.string; ctx.lineWidth = 1 + (strings - s)*0.4;
      ctx.beginPath(); ctx.moveTo(baseX, y); ctx.lineTo(baseX + fbW, y); ctx.stroke();
    }

    return {fbY, fbH, baseX, fbW, openCx};
  }
  function buildScale(root, name){
    const {intervals, degrees} = SCALES[name];
    const pcs = new Set(intervals.map(i => (root + i) % 12));
    const degreeMap = new Map(); intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));
    return {pcs, degreeMap};
  }

// スケール外のときは AChromatic Scale (All Notes) の度数にフォールバック
function getDegreeTextFor(pc, root, scaleName, degreeMap){
  const interval = (pc - root + 12) % 12;
  if (degreeMap && degreeMap.has(pc)) return degreeMap.get(pc);
  const ap = SCALES['Chromatic Scale (All Notes)'];
  if (ap && Array.isArray(ap.degrees) && ap.degrees[interval]) return ap.degrees[interval];
  return String(interval); // 念のため
}


  /* ===== 上段描画 ===== */
  function drawMain(){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const root = getKeyList().indexOf(keySel.value);
    const scaleName = scaleSel.value;
    const labelMode = labelModeSel.value;

    const cssW = mainCanvas.clientWidth|0, cssH = mainCanvas.clientHeight|0;
    mainCanvas.width = Math.floor(cssW * dpr); mainCanvas.height = Math.floor(cssH * dpr);
    mainCtx.setTransform(dpr,0,0,dpr,0,0);

    const S = styleSnapshot();
    const g = layoutOn(mainCtx, mainCanvas, STRINGS, frets, S);
    const {pcs, degreeMap} = buildScale(root, scaleName);
    const r = getNoteRadius();

    for(let s=0; s<STRINGS; s++){
      const openPc = N_SHARP.indexOf(TUNING[s]);
      const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;

const pc0 = openPc % 12;
const k0 = s + ":0";
const interval0 = (pc0 - root + 12) % 12;
if (!hiddenMap.main.has(k0)) {
// 0フレット（開放）側
drawNote(mainCtx, g.openCx, cy, r, pc0, root, getDegreeTextFor(pc0, root, scaleName, degreeMap), labelMode, keySel.value, S);
}

      for(let f=1; f<=frets; f++){
        const prevX = g.baseX + g.fbW * ((f-1)/frets);
        const thisX = g.baseX + g.fbW * (f/frets);
        const cx = (prevX + thisX)/2;
const pc = (openPc + f) % 12;
const k = s + ":" + f;
const interval = (pc - root + 12) % 12;
if (!hiddenMap.main.has(k)) {
// 1〜最終フレット側
drawNote(mainCtx, cx,       cy, r, pc,  root, getDegreeTextFor(pc,  root, scaleName, degreeMap), labelMode, keySel.value, S);
}
      }
    }

    const legend = document.getElementById('legend');
    legend.innerHTML = `
      <span class="chip"><span class="dot" style="background:var(--deg-root)"></span>ルート(1)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-third)"></span>3度(m3/M3)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-fifth)"></span>5度</span>
      <span class="chip"><span class="dot" style="background:var(--deg-seventh)"></span>7度(m7/M7)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-other)"></span>その他スケール音</span>
      <span class="chip"><span class="dot" style="background:var(--deg-blues)"></span>ブルーノート</span>
      <span>キー: <b>${keySel.value}</b></span>
      <span>スケール: <b>${scaleSel.value}</b></span>
      <span>ラベル: <b>${labelModeSel.options[labelModeSel.selectedIndex].textContent}</b></span>
    `;
  }
  mainCanvas.addEventListener('click', (ev)=>{
    const rect = mainCanvas.getBoundingClientRect();
    toggleHiddenAtPoint('main', mainCanvas, ev.clientX - rect.left, ev.clientY - rect.top, drawMain);
  });
// 上段（メイン）の全表示／全消去
const btnShowAllMain = document.getElementById('btnShowAllMain');
const btnHideAllMain = document.getElementById('btnHideAllMain');

btnShowAllMain?.addEventListener('click', ()=>{
hiddenMap.main.clear();      // 全表示＝非表示マスクを空に
  drawMain();
});

btnHideAllMain?.addEventListener('click', ()=>{
hideAllPositionsForBoard('main'); // 全消去＝全マス非表示
  drawMain();
});

/* ===== 下段：8枚描画（各ボードは独立した key/scale を使用） ===== */
function drawOnePos(canvasId){
  const el = document.getElementById(canvasId);
  if (!el) return;

  const ctx = el.getContext('2d', { alpha:true });
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));

  // ▼ 下段ボードはメインと独立した key/scale を参照
  const boardKey = getBoardKey(canvasId);
  const boardScale = getBoardScale(canvasId);

  const root = getNoteListIndexSafe(boardKey);
  const localMode = BOARD_ACCIDENTAL[canvasId] || 'flat';
  const noteNamesLocal = (localMode === 'flat') ? N_FLAT : N_SHARP;
  const scaleName = boardScale;
  const labelMode = labelModeSel.value;

  const cssW = el.clientWidth|0, cssH = el.clientHeight|0;
  el.width = Math.floor(cssW * dpr); el.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const S = styleSnapshot();
  const g = layoutOn(ctx, el, STRINGS, frets, S);

  // ▼ スケールの音（pcs）を“描画条件”にも使う（※下段はコードトーンON/OFFは無視）
  const {intervals, degrees} = SCALES[scaleName];
  const pcs = new Set(intervals.map(i => (root + i) % 12));
  const degreeMap = new Map();
  intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));

  const r = getNoteRadius();

  for (let s = 0; s < STRINGS; s++){
    const openPc = N_SHARP.indexOf(TUNING[s]);
    const cy = g.fbY + g.fbH * (s + 0.5) / STRINGS;

    // 0フレット（開放）
    const pc0 = openPc % 12;
    const k0 = s + ":0";
    if (!hiddenMap[canvasId].has(k0)) {
drawNote(ctx, g.openCx, cy, r, pc0, root, getDegreeTextFor(pc0, root, scaleName, degreeMap), labelMode, boardKey, S, noteNamesLocal);
    }

    // 1〜最終フレット
    for (let f = 1; f <= frets; f++){
      const prevX = g.baseX + g.fbW * ((f - 1) / frets);
      const thisX = g.baseX + g.fbW * (f / frets);
      const cxX = (prevX + thisX) / 2;
      const pc = (openPc + f) % 12;
      const k = s + ":" + f;
      if (!hiddenMap[canvasId].has(k)) {
// 1〜最終フレット側
drawNote(ctx, cxX, cy, r, pc, root, getDegreeTextFor(pc, root, scaleName, degreeMap), labelMode, boardKey, S, noteNamesLocal);
      }
    }
  }
}



  function drawPositions(){ POSITION_IDS.forEach(id => drawOnePos(id)); }
  POSITION_IDS.forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener('click', (ev)=>{
      const rect = el.getBoundingClientRect();
      toggleHiddenAtPoint(id, el, ev.clientX - rect.left, ev.clientY - rect.top, ()=>drawOnePos(id));
    });
  });
// 下段カードの「全表示／全消去」デリゲート
document.addEventListener('click', (e)=>{
  const btnShow = e.target.closest('.btnShowAll');
  if (btnShow){
    const id = btnShow.getAttribute('data-pos');
    if (id && hiddenMap[id]){
      hiddenMap[id].clear();       // 全表示＝非表示マスクを空に
      drawOnePos(id);
    }
    return;
  }
  const btnHide = e.target.closest('.btnHideAll');
  if (btnHide){
    const id = btnHide.getAttribute('data-pos');
    if (id && hiddenMap[id]){
      hideAllPositionsForBoard(id); // 全消去＝全マスを非表示に
      drawOnePos(id);
    }
    return;
  }

  const btnShift = e.target.closest('.btnShiftOne');
  if (btnShift){
    const id = btnShift.getAttribute('data-pos');
    const delta = parseInt(btnShift.getAttribute('data-delta'), 10) || 0;
    if (id){ shiftBoard(id, delta); drawOnePos(id); }
    return;
  }
});

// ==== コピー／ペースト ====

// （新規）メインで実際に非表示となるセル（手動＋スケール外＋コードトーン外）を収集
function collectEffectiveHiddenForMain(){
  return new Set(hiddenMap.main);
}

// メインのコピー（実描画ベースの非表示セルを保存）
document.getElementById('btnCopyMain')?.addEventListener('click', ()=>{
  const effectiveHidden = collectEffectiveHiddenForMain();
  clipboardBoard = {
    key: keySel.value,
    scale: scaleSel.value,
    hidden: Array.from(effectiveHidden),
    accidental: (typeof accidentalMode === 'string' ? accidentalMode : 'flat')
  };
  alert('メインをコピーしました');
});



// 下段カードのコピー／ペースト（デリゲート）
document.addEventListener('click', (e)=>{
  const btnCopy = e.target.closest('.btnCopyBoard');
  if (btnCopy){
    const id = btnCopy.getAttribute('data-pos');
    clipboardBoard = {
      key: getBoardKey(id),
      scale: getBoardScale(id),
      hidden: Array.from(hiddenMap[id]),
      accidental: (BOARD_ACCIDENTAL && BOARD_ACCIDENTAL[id]) || 'flat'
    };
    alert(`${id} をコピーしました`);
    return;
  }

  const btnPaste = e.target.closest('.btnPasteBoard');
  if (btnPaste){
    if (!clipboardBoard){ alert('コピーされていません'); return; }
    const id = btnPaste.getAttribute('data-pos');
    setBoardKey(id, clipboardBoard.key);
    setBoardScale(id, clipboardBoard.scale);
    hiddenMap[id] = new Set(clipboardBoard.hidden);

    // accidental apply
    if (clipboardBoard.accidental){
      if (typeof BOARD_ACCIDENTAL !== 'undefined') BOARD_ACCIDENTAL[id] = clipboardBoard.accidental;
      // adjust key spelling to accidental
      try{
        let idx = getNoteListIndexSafe(clipboardBoard.key);
        if (idx < 0) idx = 0;
        const newName = (clipboardBoard.accidental === 'flat') ? N_FLAT[idx] : N_SHARP[idx];
        setBoardKey(id, newName);
      }catch(_){}
      // update button label if present
      const btn = document.querySelector(`.btnAccToggle[data-pos="${id}"]`);
      if (btn) btn.textContent = '表記: ' + (clipboardBoard.accidental === 'flat' ? '♭' : '♯');
    }

    drawOnePos(id);
    alert(`${id} にペーストしました`);
    return;
  }
});


// 単一ボードの SHIFT（キー±1・非表示マスクを±1フレット移動）
function shiftBoard(boardId, delta){
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));

  // 1) 非表示マスクを ±1 フレットに平行移動
  const src = hiddenMap[boardId];
  if (!src) return;
  const dst = new Set();
  src.forEach(key => {
    const m = /^(\d+):(\d+)$/.exec(key);
    if(!m) return;
    const s = parseInt(m[1], 10);
    const f2 = parseInt(m[2], 10) + delta;
    if (f2 < 0 || f2 > frets) return;
    dst.add(`${s}:${f2}`);
  });

  // ★ 新しく入ってくる端の列を最初から「非表示」に追加
  if (delta !== 0){
    const enteringFret = (delta > 0) ? 0 : frets;
    for (let s = 0; s < STRINGS; s++){
      dst.add(`${s}:${enteringFret}`);
    }
  }

  hiddenMap[boardId] = dst;

  // ▼▼▼ 修正箇所：キー計算ロジックの改善 ▼▼▼
  
  // 2) ボード専用キーを ±1
  const curKey = getBoardKey(boardId);
  
  // 安全なヘルパーを使ってインデックス(0-11)を取得（現在の表記に関わらず正確な音程を取得）
  let idx = getNoteListIndexSafe(curKey);
  if (idx < 0) idx = 0; 

  // 新しいインデックスを計算
  const newIdx = (idx + delta + 12) % 12;

  // 「そのボードの設定(♯/♭)」に合わせて次のキー名を取得する
  const localMode = (BOARD_ACCIDENTAL && BOARD_ACCIDENTAL[boardId]) || 'flat';
  const targetList = (localMode === 'flat') ? N_FLAT : N_SHARP;
  const nextKey = targetList[newIdx];

  setBoardKey(boardId, nextKey);
  // ▲▲▲ 修正ここまで ▲▲▲

  // 3) 再描画
  drawOnePos(boardId);
}

function toggleHiddenAtPoint(mapKey, canvasEl, x, y, rerender){
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
  const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
  const M = {left: 120, right: 24, top: 36, bottom: 56};
  const fbY = M.top, fbH = h - M.top - M.bottom;
  const baseX = M.left, fbW = w - baseX - M.right;
  const cellW = fbW / frets;
  const openCx = baseX - cellW * 0.5;

  const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
  let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

  const centers = [openCx];
  for (let f=1; f<=frets; f++){
    const prevX = baseX + fbW * ((f-1)/frets);
    const thisX = baseX + fbW * (f/frets);
    centers.push( (prevX + thisX)/2 );
  }
  let nearestF = 0, best = Infinity;
  centers.forEach((cx, i) => { const d = Math.abs(cx - x); if (d < best){ best = d; nearestF = i; } });
  const key = `${s}:${nearestF}`;
  // === 可視トグル ===
  if (mapKey === 'main'){
    const inUser = userHiddenMain.has(key);
    const inRule = ruleHiddenMain.has(key);
    const inHidden = hiddenMap.main.has(key);
    if (inHidden){
      if (inUser){ userHiddenMain.delete(key); }
      else if (inRule){ pinnedVisibleMain.add(key); }
    } else {
      userHiddenMain.add(key);
      pinnedVisibleMain.delete(key);
    }
    rebuildMainHiddenFromLayers();
  } else {
    const setHidden = hiddenMap[mapKey];
    if (setHidden.has(key)) setHidden.delete(key); else setHidden.add(key);
  }

  (rerender || (()=>{ drawMain(); drawPositions(); }))();
}
// ==== 追加：ドラッグで非表示にする「消しゴム」機能 ====
  function hideAtPoint(mapKey, canvasEl, x, y){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;
    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
    let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

    const centers = [openCx];
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      centers.push( (prevX + thisX)/2 );
    }
    let nearestF = 0, best = Infinity;
    centers.forEach((cx, i) => { const d = Math.abs(cx - x); if (d < best){ best = d; nearestF = i; } });
    const key = `${s}:${nearestF}`;
    if (mapKey === 'main'){
      userHiddenMain.add(key);
      pinnedVisibleMain.delete(key);
      rebuildMainHiddenFromLayers();
    } else {
      hiddenMap[mapKey].add(key);
    }
  }

  let dragEraseEnabled = false;
  let isErasing = false;

  function setDragEraseUI(){
    const btn = document.getElementById('btnToggleDragErase');
    if (btn) btn.textContent = 'ドラッグ消しゴム：' + (dragEraseEnabled ? 'ON' : 'OFF');
  }

  function attachDragErase(mapKey, canvasEl, rerender){
    const getXY = (ev) => {
      const rect = canvasEl.getBoundingClientRect();
      return {
        x: (ev.clientX ?? (ev.touches && ev.touches[0]?.clientX) ?? 0) - rect.left,
        y: (ev.clientY ?? (ev.touches[0]?.clientY) ?? 0) - rect.top
      };
    };

    const onDown = (ev) => {
      if (!dragEraseEnabled) return;
      isErasing = true;
      const {x,y} = getXY(ev);
      hideAtPoint(mapKey, canvasEl, x, y);
      (rerender||(()=>{ drawMain(); drawPositions(); }))();
      ev.preventDefault?.();
    };
    const onMove = (ev) => {
      if (!dragEraseEnabled || !isErasing) return;
      const {x,y} = getXY(ev);
      hideAtPoint(mapKey, canvasEl, x, y);
      (rerender||(()=>{ drawMain(); drawPositions(); }))();
      ev.preventDefault?.();
    };
    const onUp = () => { isErasing = false; };

    canvasEl.addEventListener('pointerdown', onDown);
    canvasEl.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    canvasEl.addEventListener('pointerleave', onUp);
    // touch fallback
    canvasEl.addEventListener('touchstart', onDown, {passive:false});
    canvasEl.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);
  }

  // Eキー／ボタンクリックでON/OFF
  document.addEventListener('keydown', (e)=>{
    if (e.key && e.key.toLowerCase() === 'e'){
      dragEraseEnabled = !dragEraseEnabled;
      setDragEraseUI();
    }
  });
  document.getElementById('btnToggleDragErase')?.addEventListener('click', ()=>{
    dragEraseEnabled = !dragEraseEnabled;
    setDragEraseUI();
  });

  function bindAllDragErase(){
    attachDragErase('main', mainCanvas, drawMain);
    POSITION_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) attachDragErase(id, el, ()=>drawOnePos(id));
    });
  }


  /* ===== プリセット（localStorage） ===== */
  const LS_KEY = 'gsv_presets_v1';

  function lsGet(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return [];
      const list = JSON.parse(raw);
      return Array.isArray(list) ? list : [];
    }catch(e){ return []; }
  }
  function lsSet(list){ try{ localStorage.setItem(LS_KEY, JSON.stringify(list)); }catch(e){} }
  function renderPresetNameDatalist(list){
    presetNamesDatalist.innerHTML = '';
    list.forEach(p=>{ const opt = document.createElement('option'); opt.value = p.name; presetNamesDatalist.appendChild(opt); });
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m])); }

function renderPresetDropdown(list){
  presetList.innerHTML = '';
  if (!list.length){
    presetList.innerHTML = `<div class="empty">（保存されたプリセットはありません）</div>`;
    return;
  }

  // 並び順は localStorage の配列順を尊重（ソートしない）
  // DnD中に参照できるように id -> object をマップ化
  const byId = new Map(list.map(p => [String(p.id), p]));

  // 各行を生成（draggable対応）
  list.forEach((p) => {
    const row = document.createElement('div');
    row.className = 'preset-item';
    row.draggable = true;
    row.dataset.id = String(p.id ?? p.name ?? '');

    // ドラッグ開始/終了
    row.addEventListener('dragstart', (e)=>{
      row.classList.add('dragging');
      e.dataTransfer.setData('text/plain', row.dataset.id);
      // 画像のないドラッグ開始を可能に
      if (e.dataTransfer.setDragImage) {
        const img = new Image(); img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB'; 
        e.dataTransfer.setDragImage(img, 0, 0);
      }
    });
    row.addEventListener('dragend', ()=> row.classList.remove('dragging'));

    // ドラッグオーバー：行の前後を判定して入れ替える
    row.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const dragging = presetList.querySelector('.preset-item.dragging');
      if (!dragging || dragging === row) return;
      const rect = row.getBoundingClientRect();
      const offset = e.clientY - rect.top;
      if (offset > rect.height/2) {
        row.after(dragging);
      } else {
        row.before(dragging);
      }
    });

    // 左側（メタ：名前のみ）
    const meta = document.createElement('div'); 
    meta.className = 'preset-meta';
    meta.innerHTML = `<div class="preset-name">${escapeHtml(p.name ?? '')}</div>`;

    // 右側アクション
    const actionsWrap = document.createElement('div'); actionsWrap.className = 'row-actions';
    const loadBtn = document.createElement('button'); loadBtn.className='icon-btn'; loadBtn.textContent='読み込む';
    loadBtn.addEventListener('click', (e)=>{ e.stopPropagation(); applyPreset(p); });

    const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.textContent='🗑'; delBtn.title='削除';
    delBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (confirm(`「${p.name}」を削除しますか？`)) deletePresetFromLocal(p.id);
    });

    actionsWrap.appendChild(loadBtn);
    actionsWrap.appendChild(delBtn);

    row.appendChild(meta);
    row.appendChild(actionsWrap);

    // 行クリックで読み込み
    row.addEventListener('click', ()=> applyPreset(p));

    presetList.appendChild(row);
  });

  // コンテナ側の dragover を許可（ドロップ可能に）
  presetList.addEventListener('dragover', (e)=> e.preventDefault(), { once:false });

  // ドロップ時：DOM順から新しい配列順を保存
  // 複数回 render されてもイベントが増殖しないように先に既存の ondrop を解除
  presetList.ondrop = null;
  presetList.addEventListener('drop', ()=>{
    const ids = Array.from(presetList.querySelectorAll('.preset-item')).map(el => String(el.dataset.id));
    const newOrder = ids.map(id => byId.get(id)).filter(Boolean);
    lsSet(newOrder);
    renderPresetNameDatalist(newOrder);
  }, { once:true });
}

  function loadPresetList(){ const list = lsGet(); renderPresetDropdown(list); renderPresetNameDatalist(list); return list; }

function savePresetToLocal(preset){
  // v2: 8ボードのみ保存。キー/スケールは保存しない
  const only8 = {};
  if (preset.positions && typeof preset.positions === 'object'){
    POSITION_IDS.forEach(id => {
      const p = preset.positions[id];
      if (!p) return;
      only8[id] = {
        hidden: Array.isArray(p.hidden) ? p.hidden : [],
        title:  (typeof p.title === 'string' ? p.title : ''),
        key: getBoardKey(id),
        scale: getBoardScale(id)
      };
    });
  } else {
    // v1 相当が来た場合でも、現状DOMから 8ボードの hidden/title を作る
    POSITION_IDS.forEach(id => {
      only8[id] = {
        hidden: Array.from(hiddenMap[id] || []),
        title: (posNameEls[id]?.textContent ?? '').trim(),
        key: getBoardKey(id),
        scale: getBoardScale(id)
      };
    });
  }

  const v2 = {
    version: 2,
    id: preset.id,
    name: preset.name,
    updatedAt: Date.now(),
    frets: parseInt(fretSel.value || '16', 10),
    labelMode: labelModeSel.value,
    positions: only8
  };

  const list = lsGet();
let idx = list.findIndex(x => x.id === v2.id || x.name === v2.name);
// 既存に同名(ID含む)がある場合は確認ダイアログ
if (idx >= 0) {
  const ok = confirm(`「${v2.name}」は既に保存されています。上書きしますか？`);
  if (!ok) {
    presetMeta.textContent = `保存をキャンセル: ${v2.name}（既存名）`;
    renderPresetDropdown(list);
    renderPresetNameDatalist(list);
    return;
  }
  list[idx] = v2;
} else {
  list.push(v2);
}
lsSet(list);
renderPresetDropdown(list);
  renderPresetNameDatalist(list);
  presetMeta.textContent = `保存しました: ${v2.name}（8ボードのみ／キー・スケールは保存しません）`;
}

  function deletePresetFromLocal(id){ const list = lsGet().filter(x => x.id !== id); lsSet(list); renderPresetDropdown(list); renderPresetNameDatalist(list); presetMeta.textContent = 'プリセットを削除しました'; }



function applyPreset(preset){
  if (!preset || typeof preset !== 'object') return;

  // v2: positions がオブジェクトなら 8ボードのみを更新（メインのキー/スケールは変更しない）
  if (preset && preset.positions && typeof preset.positions === 'object') {
    // 8ボードの show/hidden をリセットしつつ、key/scale/hidden/title を反映
    POSITION_IDS.forEach(id => {
      const p = preset.positions[id] || {};
      // key/scale は JSON から。欠落時は現状を維持（メインにも依存しない）
      const k = (typeof p.key === 'string')   ? p.key   : getBoardKey(id);
      const s = (typeof p.scale === 'string') ? p.scale : getBoardScale(id);
      setBoardKey(id, k);
      setBoardScale(id, s);

      hiddenMap[id].clear();
      (Array.isArray(p.hidden) ? p.hidden : []).forEach(v => hiddenMap[id].add(v));

      if (posNameEls[id] && typeof p.title === 'string'){
        const t = p.title.trim();
        if (t) posNameEls[id].textContent = t;
      }
    });

    // frets/labelMode（存在する場合）はUIへ反映（キーではない）
    if (typeof preset.frets === 'number')      fretSel.value = String(preset.frets);
    if (typeof preset.labelMode === 'string')  labelModeSel.value = preset.labelMode;

    // メインのキー/スケールは preset に関係なく現状を維持する
    presetNameInput.value = preset.name || '';
    drawPositions(); // 下段のみ再描画（メインは触らない）
    presetMeta.textContent = `読み込み: ${preset.name ?? ''}（8ボードの非表示/名称/キー/スケールを復元）`;
    presetDropdown.open = false;
    return;
  }

  // --- v1 後方互換：positions が無い形式（hidden/title などのみ） ---
  if (preset && preset.hidden){
    Object.keys(hiddenMap).forEach(k=>{
      if (k === 'main') return; // メインは変更しない
      hiddenMap[k].clear();
      (preset.hidden?.[k] || []).forEach(v=> hiddenMap[k].add(v));
    });
  }
  if (preset && preset.posTitles && typeof preset.posTitles === 'object') {
    POSITION_IDS.forEach(id => {
      const el = posNameEls[id]; if (!el) return;
      const val = preset.posTitles[id];
      if (typeof val === 'string' && val.trim().length) el.textContent = val.trim();
    });
  }
  presetNameInput.value = preset?.name || '';
  drawPositions(); // 下段のみ
  presetMeta.textContent = `読み込み: ${preset?.name ?? ''}`;
  presetDropdown.open = false;

  if (preset && preset.positions && typeof preset.positions === 'object'){
    // ▼ メインのキー/スケールがあれば先に反映（互換性: 無ければ現状維持）
    if (typeof preset.mainKey === 'string') 
    if (typeof preset.mainScale === 'string') 
    // （メイン反映後に）下段へも描画前にキー/スケールを配布（無ければ main を既定に）
    POSITION_IDS.forEach(id => {
      const p = preset.positions[id] || {};
      const k = (typeof p.key === 'string') ? p.key : (preset.mainKey || keySel.value);
      const s = (typeof p.scale === 'string') ? p.scale : (preset.mainScale || scaleSel.value);
      setBoardKey(id, k);
      setBoardScale(id, s);
    });

    if (typeof preset.frets === 'number')      fretSel.value = String(preset.frets);
    if (typeof preset.labelMode === 'string')  labelModeSel.value = preset.labelMode;

    // 8ボードの hidden/title だけ反映（キー/スケールは無視）
    POSITION_IDS.forEach(id => {
      const p = preset.positions[id];
      if (!p) return;

      hiddenMap[id].clear();
      (Array.isArray(p.hidden) ? p.hidden : []).forEach(v => hiddenMap[id].add(v));

      if (posNameEls[id] && typeof p.title === 'string'){
        const t = p.title.trim();
        if (t) posNameEls[id].textContent = t;
      }
    });

    presetNameInput.value = preset.name || '';
    drawAll();
    presetMeta.textContent = `読み込み: ${preset.name}（8ボードの非表示/名称/キー/スケールを復元）`;
    presetDropdown.open = false;
    return;
  }

  // --- v1 後方互換：キー/スケールは無視する ---
  // frets/labelMode は反映OK
  if (preset && preset.meta){
    if (typeof preset.meta.frets === 'number')     fretSel.value = String(preset.meta.frets);
    if (typeof preset.meta.labelMode === 'string') labelModeSel.value = preset.meta.labelMode;
    // preset.meta.key / preset.meta.scale は無視
  }
  // hidden は従来どおり反映（main/各posともOK）
  if (preset && preset.hidden){
    Object.keys(hiddenMap).forEach(k=>{
      hiddenMap[k].clear();
      (preset.hidden?.[k] || []).forEach(v=> hiddenMap[k].add(v));
    });
  }
  // posTitles もそのまま反映
  if (preset && preset.posTitles && typeof preset.posTitles === 'object') {
    POSITION_IDS.forEach(id => {
      const el = posNameEls[id]; if (!el) return;
      const val = preset.posTitles[id];
      if (typeof val === 'string' && val.trim().length) el.textContent = val.trim();
    });
  }

  presetNameInput.value = preset?.name || '';
  drawAll();
  // メタ表記もキー/スケールを出さない
  presetMeta.textContent = `読み込み: ${preset?.name ?? ''}（キー/スケールは無視）`;
  presetDropdown.open = false;
}

  // 保存/読込ボタン
  btnSavePreset.addEventListener('click', ()=>{ const name = (presetNameInput.value || '').trim(); if (!name){ alert('プリセット名を入力してください'); presetNameInput.focus(); return; } savePresetToLocal( currentStateToPreset(name) ); });
  presetNameInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); btnSavePreset.click(); } });
  btnExportPreset.addEventListener('click', ()=>{
    const name = (presetNameInput.value || 'preset').replace(/[\\/:*?"<>|]/g,'_');
    const preset = currentStateToPreset(name);
    const blob = new Blob([JSON.stringify(preset,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${name}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    presetMeta.textContent = `JSONを書き出しました: ${name}.json`;
  });
  btnImportPreset.addEventListener('click', ()=> importFile.click());
  importFile.addEventListener('change', async ()=>{
    const file = importFile.files && importFile.files[0]; if (!file) return;
    let textRaw = '';
    try{ textRaw = await file.text(); }catch(e){ alert('ファイルの読み込みに失敗: ' + (e && e.message ? e.message : e)); console.error('file.text() error', e); importFile.value = ''; return; }
    try{
      const sanitize = (s)=>{ s = s.replace(/^\uFEFF/, ''); s = s.replace(/\/\/[^\n\r]*/g, '').replace(/\/\*[\s\S]*?\*\//g, ''); s = s.replace(/,\s*(\}|\])/g, '$1'); return s.trim(); };
      let text = typeof textRaw === 'string' ? textRaw : String(textRaw||'');
      let preset; try{ preset = JSON.parse(text.replace(/^\uFEFF/, '')); }catch(parseErr){ try{ const cleaned = sanitize(text); preset = JSON.parse(cleaned); console.warn('JSONをクリーンアップして読み込みました'); }catch(e2){ const head = text.slice(0,200); alert('読み込みに失敗しました: ' + (parseErr && parseErr.message ? parseErr.message : parseErr) + '\n\n先頭抜粋:\n' + head); console.error('Import JSON head:', head, parseErr, e2); return; } }
      let name = (preset.name || preset.id || 'imported'); name = String(name ?? 'imported').trim() || 'imported';
      preset.id = name; preset.name = name; preset.updatedAt = Date.now();
      const fixHidden = (h)=>{ const out = {}; try{ const keys = (typeof hiddenMap !== 'undefined' && hiddenMap) ? Object.keys(hiddenMap) : (h ? Object.keys(h) : []); keys.forEach(k=>{ const v = h && h[k]; out[k] = Array.isArray(v) ? v : (v instanceof Set) ? Array.from(v) : (v && typeof v === 'object') ? Object.values(v).flat() : []; }); }catch(e){} return out; };
      if (preset.hidden) preset.hidden = fixHidden(preset.hidden);
      if (typeof savePresetToLocal === 'function') savePresetToLocal(preset);
      if (typeof applyPreset === 'function') applyPreset(preset);
    }finally{ importFile.value = ''; }
  });

  /* ===== 入力変更時の挙動（下段はリセットしない） ===== */
  function drawAll(){ syncDPR(); drawMain(); drawPositions(); }

// キー変更 → メインだけ再描画（状態は維持）
['input','change'].forEach(evt => {
  keySel.addEventListener(evt, () => { pinnedVisibleMain.clear(); userHiddenMain.clear(); ruleHiddenMain.clear(); autoHideOutOfScaleMain(); drawMain(); });
});

// スケール変更 → メインを「全表示」相当でリセットしてから再描画
['input','change'].forEach(evt => {
  scaleSel.addEventListener(evt, () => { pinnedVisibleMain.clear(); userHiddenMain.clear(); ruleHiddenMain.clear(); autoHideOutOfScaleMain(); drawMain(); });
});
  // フレット数／ラベル表示 → 全体を再描画（非表示マスクは維持）
  ['input','change'].forEach(evt => {
    [fretSel, labelModeSel].forEach(el => { el.addEventListener(evt, () => { drawAll(); autoHideOutOfScaleMain(); rebuildMainHiddenFromLayers(); drawMain(); }); });
  });

  window.addEventListener('resize', () => drawAll());


   /* 初期表示 */
   (function init(){
     applyDefaultTitles();


     // ▼ 下段8ボードを「初期状態＝全ポジション非表示」にセット（メインは対象外）
     POSITION_IDS.forEach(id => hideAllPositionsForBoard(id));

     drawAll(); autoHideOutOfScaleMain(); rebuildMainHiddenFromLayers(); drawMain();
     loadPresetList();
     bindAllDragErase();
     setDragEraseUI();
   })();(() => {
  // A4縦・余白5mmに1ページでフィット
  const PAGE_MM = { w: 210, h: 297, margin: 5 };

  function getPresetTitle() {
    const el = document.getElementById('presetName');
    const name = (el && el.value || '').trim();
    return name || '未保存のプリセット';
  }
  function getMetaLine() {
    const keySel = document.getElementById('keySelect');
    const scaleSel = document.getElementById('scaleSelect');
    return `${keySel?.value || ''} / ${scaleSel?.value || ''}`;
  }  

 // 画面の「上段指板＋7ポジション」を縦一列で合成（PDF用ライト配色で再描画／各ポジションに小見出し）
function composeExportCanvas() {

// ▼ 下段8ボードのみ（上段メインは含めない）※欠けていた pos-4-M も含める
  const ids = ["pos-6-I","pos-6-M","pos-6-P","pos-5-I","pos-5-M","pos-5-P","pos-4-I","pos-4-M"];
  const list = ids.map(id => document.getElementById(id)).filter(Boolean);

// 出力キャンバスの横幅（品質重視）
  const outW = 3000;
  const POS_RATIO  = 0.18;                         // 各ポジションの高さ = outW * 0.18
  const scaledHeights = list.map(() => Math.round(outW * POS_RATIO));

  // タイトル領域（コンパクト）
  const gap = Math.round(outW * 0.0025);
  const titleFontPx = Math.round(outW * 0.022);
  const metaFontPx  = Math.round(outW * 0.012);
  const titlePad    = Math.round(outW * 0.016);
  const titleAreaH  = titlePad + titleFontPx + Math.round(metaFontPx * 1.1) + Math.round(titlePad * 0.4);

  // 各ポジション小見出し（全行に付ける）
  const subFontPx = Math.round(outW * 0.018);
  const subPad    = Math.round(outW * 0.010);
  const labelHeights = list.map(() => (subFontPx + subPad));

  // DOM からポジション名を取得（なければフォールバック）
  const posTitles = ids.map((id, i) => {
    const el = document.querySelector(`.pos-name[data-pos="${id}"]`);
    const txt = (el && el.textContent && el.textContent.trim()) || `タイトル${i+1}`;
    return txt;
  });

  const totalH = titleAreaH
    + scaledHeights.reduce((a,b)=>a+b,0)
    + labelHeights.reduce((a,b)=>a+b,0)
    + gap * (list.length - 1);

  // ▼ PDF用ライト配色（反転）
  const LightStyle = (() => {
    const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
    return {
      board1:'#f2f4f8', board2:'#e8ecf3',
      nut:'#222',
      fret:'#c3c9d6',
      string:'#000000',
      posBorder:'#000000',
      labelInk:'#000000',
      muted:'#000000',
      degRoot:css('--deg-root'),
      degThird:css('--deg-third'),
      degFifth:css('--deg-fifth'),
      degSeventh:css('--deg-seventh'),
      degOther:css('--deg-other'),
      degBlues:css('--deg-blues'),
    };
  })();

function renderLightSnapshot(targetW, targetH, mapKey){
  const frets = Math.max(12, Math.min(24, parseInt((document.getElementById('fretCount')?.value)||'16')));
  let keyName   = document.getElementById('keySelect')?.value || 'C';
  let scaleName = document.getElementById('scaleSelect')?.value || 'Major (Ionian)';
  const labelMode = document.getElementById('labelMode')?.value || 'both';
  // If mapKey is a lower-board id, use that board's key/scale
  try{
    if (typeof getBoardKey==='function' && typeof getBoardScale==='function' && Array.isArray(POSITION_IDS) && POSITION_IDS.includes(mapKey)){
      keyName = getBoardKey(mapKey);
      scaleName = getBoardScale(mapKey);
    }
  }catch(_){/* fallback to main */}
  const root = (typeof getNoteListIndexSafe==='function') ? getNoteListIndexSafe(keyName) : getKeyList().indexOf(keyName);
  // Per-board accidental (sharp/flat)
  const localAcc = (typeof BOARD_ACCIDENTAL!=='undefined' && BOARD_ACCIDENTAL[mapKey]) || (typeof globalThis.accidentalMode==='string' ? globalThis.accidentalMode : 'flat');
  const noteNamesLocal = (localAcc === 'flat') ? N_FLAT : N_SHARP;

  const prevDpr = (typeof dpr!=='undefined'? dpr:1);
  if (typeof dpr!=='undefined') dpr = 1; // エクスポートは DPR=1 固定

  const off = document.createElement('canvas');
  off.width = targetW; off.height = targetH;
  const ctx = off.getContext('2d');
  ctx.setTransform(1,0,0,1,0,0);

  // PDF用ライト配色
  const LightStyle = (() => {
    const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
    return {
      board1:'#f2f4f8', board2:'#e8ecf3',
      nut:'#222',
      fret:'#c3c9d6',
      string:'#000000',
      posBorder:'#000000',
      labelInk:'#000000',
      muted:'#000000',
      degRoot:css('--deg-root'),
      degThird:css('--deg-third'),
      degFifth:css('--deg-fifth'),
      degSeventh:css('--deg-seventh'),
      degOther:css('--deg-other'),
      degBlues:css('--deg-blues'),
    };
  })();

  const g = layoutOn(ctx, off, STRINGS, frets, LightStyle);

  // フレット番号帯を白で拭ってから大きく描き直し
  (() => {
    ctx.save();
    const fretW = g.fbW / frets;
    const wipeH = Math.round(g.fbH * 0.03);
    const wipeY = g.fbY + g.fbH + Math.round(g.fbH * 0.01);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(g.baseX - Math.round(fretW*0.6) - 2, wipeY - 2, g.fbW + Math.round(fretW*0.6)*2 + 4, wipeH + 4);
    ctx.restore();

    const FRET_FONT_SCALE = 0.6;
    const fontPx = Math.round(g.fbH * 0.10 * FRET_FONT_SCALE);
    ctx.font = "700 " + fontPx + "px system-ui";
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const y = g.fbY + g.fbH + Math.round(fontPx * 0.10);
    for (let f = 0; f <= frets; f++) {
      const cx = (f === 0) ? g.baseX - fretW / 2 : g.baseX + fretW * (f - 0.5);
      ctx.fillText(String(f), cx, y);
    }
  })();

  // スケール情報
  const {intervals, degrees} = SCALES[scaleName];
  const pcs = new Set(intervals.map(i => (root + i) % 12));
  const degreeMap = new Map(); intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));
  const NOTE_RADIUS_SCALE = 1.8;
  const r = getNoteRadius() * NOTE_RADIUS_SCALE;

  for(let s=0; s<STRINGS; s++){
    const openPc = N_SHARP.indexOf(TUNING[s]);
    const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;

    // 0フレット（開放）
    const pc0 = openPc % 12;
    const k0 = s + ":0";
    const interval0 = (pc0 - root + 12) % 12;
    if (!hiddenMap[mapKey]?.has(k0)) {
      drawNote(ctx, g.openCx, cy, r, pc0, root, getDegreeTextFor(pc0, root, scaleName, degreeMap), labelMode, keyName, LightStyle, noteNamesLocal);
    }

    // 1..frets
    for(let f=1; f<=frets; f++){
      const prevX = g.baseX + g.fbW * ((f-1)/frets);
      const thisX = g.baseX + g.fbW * (f/frets);
      const cx = (prevX + thisX)/2;
      const pc = (openPc + f) % 12;
      const k = s + ":" + f;
      const interval = (pc - root + 12) % 12;
      if (!hiddenMap[mapKey]?.has(k)) {
        drawNote(ctx, cx, cy, r, pc, root, getDegreeTextFor(pc, root, scaleName, degreeMap), labelMode, keyName, LightStyle, noteNamesLocal);
      }
    }
  }

  if (typeof dpr!=='undefined') dpr = prevDpr;
  return off;
}

// 合成キャンバス生成
  const off = document.createElement('canvas');
  off.width = outW;
  off.height = totalH;
  const ctx = off.getContext('2d');
  ctx.clearRect(0, 0, off.width, off.height);

// 背景を白で塗る（透明防止）
  ctx.save(); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, off.width, off.height); ctx.restore();

// タイトルとメタ行
  ctx.fillStyle = '#000000';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = "700 " + titleFontPx + "px system-ui";
  ctx.fillText(getPresetTitle(), titlePad, titlePad);
  ctx.font = "500 " + metaFontPx + "px system-ui";
  ctx.fillStyle = '#333333';

// 各ボード（全8枚）を貼り付け（それぞれに小見出し）
  let yPos = titleAreaH;
  list.forEach((src, i) => {
// 小見出し
    ctx.font = "600 " + subFontPx + "px system-ui";
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(posTitles[i] || `ポジション${i+1}`, Math.round(outW * 0.01), yPos);
    yPos += (subFontPx + subPad);

    const mapKey = ids[i]; // 下段ボードID
    const lightCanvas = renderLightSnapshot(outW, scaledHeights[i], mapKey);
    ctx.drawImage(lightCanvas, 0, yPos);
    yPos += scaledHeights[i];
    if (i < list.length - 1) yPos += gap;
  });

  return off;
}function exportPDF() {
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) { alert('PDFライブラリ（jsPDF）が読み込めていません'); return; }

    const composed = composeExportCanvas();

    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    const m = PAGE_MM.margin;
    const contentW = PAGE_MM.w - m * 2;
    const contentH = PAGE_MM.h - m * 2;

    const imgWmm = contentW;
    const imgHmm = (contentW * composed.height) / composed.width;
    // 高さが足りなければ等比で縮小 → 1ページに収める
    const scale = Math.min(1, contentH / imgHmm);
    const drawW = imgWmm * scale;
    const drawH = imgHmm * scale;
    const x = m + (contentW - drawW) / 2;
    const y = m + (contentH - drawH) / 2;

    const dataURL = composed.toDataURL('image/png');
    doc.addImage(dataURL, 'PNG', x, y, drawW, drawH, undefined, 'FAST');

    const name = getPresetTitle().replace(/[\\/:*?"<>|]/g, '_') || 'export';
    doc.save(`${name}.pdf`);
  }

  // 既存ボタンにだけハンドラを追加（DOM/CSSは一切変更しない）
  const btn = document.getElementById('btnExportPdf');
  if (btn) btn.addEventListener('click', exportPDF);
})();
function currentStateToPreset(name){
  // v2: 8ボードの hidden/title/key/scale を保存（メインのキー/スケールは含めない）
  const positions = {};
  POSITION_IDS.forEach(id => {
    positions[id] = {
      hidden: Array.from(hiddenMap[id] || []),
      title:  (posNameEls[id]?.textContent ?? '').trim(),
      key:    getBoardKey(id),
      scale:  getBoardScale(id)
    };
  });
  const frets = parseInt(fretSel.value || '16', 10);
  const labelMode = labelModeSel.value;
  return {
    version: 2,
    id: name,
    name,
    updatedAt: Date.now(),
    frets,
    labelMode,
    positions
    // ※ mainKey/mainScale は出力しない（メインは無関係）
  };
}
</script>



<!-- Patch v2.10: Main board click/visibility logic stabilization -->
<script id="patch_v210_mainfix">
(function(){
  try{
    // --- Utility: safely rebind a button's click handler by replacing the node (removes prior listeners) ---
    function rebindClick(id, handler){
      const btn = document.getElementById(id);
      if(!btn) return null;
      const clone = btn.cloneNode(true);
      btn.parentNode.replaceChild(clone, btn);
      clone.addEventListener('click', handler);
      return clone;
    }

    // --- 1) Override toggleHiddenAtPoint for 'main' to use userHiddenMain layer ---
    const originalDPR = (typeof dpr !== 'undefined') ? dpr : 1;
    window.toggleHiddenAtPoint = function(mapKey, canvasEl, x, y, rerender){
      // Dependencies expected from main script:
      // STRINGS, dpr, drawMain, hiddenMap, userHiddenMain, rebuildMainHiddenFromLayers
      try{
        const fretSelEl = document.getElementById('fretCount');
        const frets = Math.max(12, Math.min(24, parseInt((fretSelEl && fretSelEl.value) || '16')));

        const w = canvasEl.width / (window.dpr||originalDPR), h = canvasEl.height / (window.dpr||originalDPR);
        const M = {left: 120, right: 24, top: 36, bottom: 56};
        const fbY = M.top, fbH = h - M.top - M.bottom;
        const baseX = M.left, fbW = w - baseX - M.right;
        const cellW = fbW / frets;
        const openCx = baseX - cellW * 0.5;

        // 弦 index を決定
        const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
        let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

        // 近いフレット中心（開放含む）
        const centers = [openCx];
        for (let f=1; f<=frets; f++){
          const prevX = baseX + fbW * ((f-1)/frets);
          const thisX = baseX + fbW * (f/frets);
          centers.push((prevX + thisX)/2);
        }
        let fSel = 0, best = Infinity;
        for (let f=0; f<centers.length; f++){
          const d = Math.abs(x - centers[f]);
          if (d < best){ best = d; fSel = f; }
        }
        const key = `${s}:${fSel}`;

        if (mapKey === 'main'){
          if (userHiddenMain.has(key)) userHiddenMain.delete(key); else userHiddenMain.add(key);
          if (typeof rebuildMainHiddenFromLayers === 'function') rebuildMainHiddenFromLayers();
          if (typeof rerender === 'function') rerender(); else if (typeof drawMain === 'function') drawMain();
        } else {
          const set = hiddenMap[mapKey];
          if (!set) return;
          if (set.has(key)) set.delete(key); else set.add(key);
          if (typeof rerender === 'function') rerender();
        }
      }catch(e){
        console.error('[patch_v210] toggleHiddenAtPoint error', e);
      }
    };

    // --- 2) Rebind "全表示" for main ---
    rebindClick('btnShowAllMain', function(){
      try{
        if (typeof userHiddenMain?.clear === 'function') userHiddenMain.clear();
        if (typeof pinnedVisibleMain?.clear === 'function') pinnedVisibleMain.clear();
        if (typeof autoHideOutOfScaleMain === 'function') autoHideOutOfScaleMain();
        if (typeof rebuildMainHiddenFromLayers === 'function') rebuildMainHiddenFromLayers();
        if (typeof drawMain === 'function') drawMain();
      }catch(e){ console.error('[patch_v210] btnShowAllMain', e); }
    });

    // --- 3) Rebind "全消去" for main ---
    rebindClick('btnHideAllMain', function(){
      try{
        if (typeof ruleHiddenMain?.clear === 'function') ruleHiddenMain.clear();
        if (typeof pinnedVisibleMain?.clear === 'function') pinnedVisibleMain.clear();
        if (typeof userHiddenMain?.clear === 'function') userHiddenMain.clear();

        const fretSelEl = document.getElementById('fretCount');
        const frets = Math.max(12, Math.min(24, parseInt((fretSelEl && fretSelEl.value) || '16')));

        for (let s = 0; s < STRINGS; s++){
          for (let f = 0; f <= frets; f++){
            userHiddenMain.add(`${s}:${f}`);
          }
        }
        if (typeof rebuildMainHiddenFromLayers === 'function') rebuildMainHiddenFromLayers();
        if (typeof drawMain === 'function') drawMain();
      }catch(e){ console.error('[patch_v210] btnHideAllMain', e); }
    });

    console.log('%c[patch_v210_mainfix] loaded','color:#0f0');
  }catch(e){
    console.error('[patch_v210] init failed', e);
  }
})();
</script>

<script>
// 下段「表記: ♭/♯」トグル
document.addEventListener('click', function(e){
  const t = e.target.closest('.btnAccToggle'); if (!t) return;
  const id = t.getAttribute('data-pos'); if (!id) return;
  const cur = (BOARD_ACCIDENTAL && BOARD_ACCIDENTAL[id]) || 'flat';
  const next = (cur === 'flat') ? 'sharp' : 'flat';
  BOARD_ACCIDENTAL[id] = next;

  // ボタン表示更新
  t.textContent = '表記: ' + (next === 'flat' ? '♭' : '♯');

  // ボードのキー名の表記も合わせる（C# <-> Db など）
  if (typeof getBoardKey === 'function' && typeof setBoardKey === 'function' && typeof getNoteListIndexSafe === 'function'){
    const k = getBoardKey(id);
    let idx = getNoteListIndexSafe(k);
    if (idx < 0) idx = 0;
    const newName = (next === 'flat') ? N_FLAT[idx] : N_SHARP[idx];
    setBoardKey(id, newName);
  }

  // 再描画
  if (typeof drawOnePos === 'function') drawOnePos(id);
});
</script>

</body>
</html>
