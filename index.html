<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Scales and Fretboard Editor Ver 2.0.6</title>
  <script src="./jspdf.umd.min.js"></script>
  <style>
    :root{
      /* Dark (default) palette */
      --bg:#0f1115; --panel:#171a21; --ink:#e6e6e6; --muted:#9aa4b2; --accent:#4f8cff;
      --board1:#1b222d; --board2:#121821; --nut:#e2e8f0; --fret:#293042; --string:#d1d7e1;
      --pos-border:#ffffff;  /* ダーク時のポジション縁：白 */
      --label-ink:#000000;   /* 円内の文字色 */
      --deg-root:#3b82f6; --deg-third:#22c55e; --deg-fifth:#ef4444; --deg-seventh:#ec4899; --deg-other:#32d296; --deg-blues:#ffd166;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height:1.5; display:flex; flex-direction:column; min-height:100vh;
    }
    header{
      padding:12px 16px; border-bottom:1px solid #232735;
      background:linear-gradient(180deg, rgba(21,24,35,.85), rgba(20,23,32,.85));
    }
/* 共通の .toolbar はデフォルト最小限（プリセットなど他所は今まで通り） */
.toolbar{
  display:grid; gap:10px;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  align-items:end; max-width:90vw; margin:0 auto;
}

/* ▼ 上段（ヘッダー）のツールバーだけを “左詰め・収縮” にする */
.toolbar.toolbar--main{
  /* 列の自動生成を「中身に合わせて詰める」モードに */
  grid-template-columns: none;
  grid-auto-flow: column;
  grid-auto-columns: max-content;
}

/* 上段だけはコントロールの 100% 幅を解除してコンテンツ幅に */
.toolbar.toolbar--main select,
.toolbar.toolbar--main button,
.toolbar.toolbar--main input[type="text"]{
  width: auto;
}

/* 1列目（キー）と2列目（スケール）の最小/最大幅は上段だけに適用 */
.toolbar.toolbar--main > div:first-child{  /* キー */
  max-width: 96px;   /* #keySelect (88〜96px) と整合 */
}
.toolbar.toolbar--main > div:nth-child(2){ /* スケール */
  min-width: 140px;
}
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type="text"], select, button{
      width:100%; padding:10px 12px; border-radius:12px;
      border:1px solid #2a2f40; background:var(--panel); color:var(--ink); outline:none;
    }
    select:focus, button:focus, input[type="text"]:focus { border-color: var(--accent); }

    /* --- ここから追記 --- */

    /* 1) キーのセレクト幅を圧縮して、右側ボタンの折返しを防止 */
    #keySelect{
      width: 88px;      /* 目安：現状の約1/2。必要に応じて 80–96px で微調整 */
      min-width: 80px;
    }

    /* 2) 上段の「全表示」「全消去」「コピー」を折り返さない＋最小幅を確保 */
    #btnShowAllMain,
    #btnHideAllMain,
    #btnCopyMain{
      white-space: nowrap;   /* 折返し防止 */
    }
    #btnShowAllMain,
    #btnHideAllMain{
      min-width: 84px;       /* 日本語2語の折返し防止 */
    }
    #btnCopyMain{
      min-width: 68px;       /* 「コピー」の最小幅 */
    }
    /* --- 追記ここまで --- */
    main{ padding:16px; display:grid; place-items:center; }
    .card{
      width:100%; max-width:90vw; background:var(--panel);
      border:1px solid #232735; border-radius:12px; padding:12px; margin-bottom:12px;
    }

    canvas{ width:100%; height:360px; display:block; border-radius:12px; background:transparent; }

    .legend{ display:flex; gap:8px; flex-wrap:wrap; font-size:12px; color:var(--muted); padding-top:8px; }
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid #2a2f40; background:var(--panel); }
    .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    .foot { color:var(--muted); text-align:center; font-size:12px; margin-top:8px; }

    .positions{ width:100%; max-width:90vw; margin:0 auto; display:flex; flex-direction:column; gap:12px; }
    .pos-card{ background:var(--panel); border:1px solid #232735; border-radius:12px; padding:12px; }
    .pos-title{ font-size:12px; color:var(--muted); margin:4px 0 8px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .pos-name{ color:var(--ink); font-weight:600; outline: none; padding: 2px 6px; border-radius: 8px; }
    .pos-name:focus{ box-shadow: 0 0 0 2px rgba(79,140,255,0.35); background: rgba(79,140,255,0.08); }
    .pos-canvas{ width:100%; height:360px; display:block; border-radius:12px; }
.pos-actions{ display:flex; gap:8px; }

/* 下段アクションボタンの折返し方針 */
.pos-actions { flex-wrap: wrap; }   /* モバイル等は折返し許容 */
@media (min-width: 768px){
  .pos-actions { flex-wrap: nowrap; }  /* PC幅では横一列に */
}

/* 下段アクションボタンの折返し防止（必要な場合のみ） */
.pos-actions { flex-wrap: wrap; } /* 折返し許容なら wrap のまま */
@media (min-width: 768px){
  .pos-actions { flex-wrap: nowrap; }
}

.icon-btn{ border:1px solid #2a2f40; background:transparent; color:var(--ink); padding:6px 10px; border-radius:10px; cursor:pointer; }

/* 下段アクションのうち「SHIFT / ペースト」は折り返し禁止＋最小幅を拡張 */
.pos-actions .btnShiftOne,
.pos-actions .btnPasteBoard{
  white-space: nowrap;   /* ← ボタン内の改行を抑止 */
  min-width: 108px;      /* ← 少し広げる（100〜120の範囲でお好みで） */
}

/* 「全表示」「全消去」「コピー」は今のままでもOKだが、気になるようなら最小幅を少し確保 */
.pos-actions .btnShowAll{ min-width: 76px; }
.pos-actions .btnHideAll{ min-width: 76px; }
.pos-actions .btnCopyBoard{ min-width: 76px; }
    .icon-btn:hover{ border-color:var(--accent); }

    details.dropdown{ border:1px solid #2a2f40; border-radius:12px; background:var(--panel); overflow:hidden; }
details.dropdown > summary{
  list-style: none;
  cursor: pointer;
  padding: 10px 12px;
  border-radius: 12px;
  outline: none;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: space-between; /* ← タイトルと「▾」が左右にきれいに配置される */
  width: 100%;                    /* ← クリック範囲がカード幅いっぱいになる */
}
    details.dropdown[open] > summary{ border-bottom:1px solid #2a2f40; border-bottom-left-radius:0; border-bottom-right-radius:0; }
    details.dropdown .menu{ max-height:320px; overflow:auto; padding:4px 0; }
    .preset-item{ display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border-bottom:1px solid #232735; cursor:pointer; }
    .preset-item:last-child{ border-bottom:none; }
    .preset-item:hover{ background: rgba(255,255,255,0.04); }
    .preset-item.dragging{ opacity:0.5; }
    .preset-meta{ flex:1; min-width:0; }
    .preset-name{ font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .preset-sub{ font-size:11px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .row-actions{ display:flex; gap:8px; }
    .empty{ color:var(--muted); padding:12px; font-size:13px; }
    .notice{ color:#9aa4b2; font-size:12px; margin-top:8px; }

/* === 横長で小さい +1 / -1 ボタン用（※posShift用は小さいまま） === */
#btnPosShiftDown,
#btnPosShiftUp {
  width: auto;
  padding: 4px 14px;
}

/* === ツールバーに並ぶボタンの高さを揃える（キー/スケール/PDF などと同じ） === */
#btnToggleChordTones,
#btnToggleDragErase {
  width: 100%;
  padding: 10px 12px;  /* 他ボタンと同じ */
}

<style id="preset-tweaks">
  /* プリセット名の下のサブ情報を完全に非表示 */
  .preset-sub{ display:none !important; }

  /* リスト行をスリムに */
  .preset-item{
    display:flex;            /* もし既存でflexならこの指定は重複OK */
    align-items:center;
    justify-content:space-between;
    padding: 6px 10px;       /* ← 上下を小さく */
    gap: 8px;
  }
  .preset-meta .preset-name{
    line-height: 1.2;        /* 行の背を低く */
    margin: 0;
  }

/* 右側ボタン（読み込む／ゴミ箱）を横長・低背に */
.row-actions{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;              /* ← 行を折り返さない */
}

.row-actions .icon-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:4px 12px;              /* 横は少し長め、縦は薄く */
  height:28px;                   /* 行の背を下げる */
  line-height:1;
  font-size:12px;
  border-radius:6px;
  white-space:nowrap;            /* ← ボタン内の文字折り返し禁止 */
}

/* 「読み込む」だけ少しワイドにして折り返し防止 */
.row-actions .icon-btn:first-child{
  min-width:96px;                /* 環境次第で 88〜110px で調整 */
  padding-inline:14px;
}

/* ゴミ箱はコンパクトのまま */
.row-actions .icon-btn[title="削除"]{
  min-width:0;
  padding-inline:8px;
}
</style>


  </style>
</head>
<body>
<header>
  <div class="toolbar toolbar--main">
    <div>
      <label for="keySelect">キー</label>
      <select id="keySelect"></select>
    </div>
    <div>
      <label for="scaleSelect">スケール</label>
      <select id="scaleSelect"></select>
    </div>
    <div>
      <label for="labelMode">ラベル表示</label>
      <select id="labelMode">
        <option value="note">音名</option>
        <option value="degree">度数</option>
        <option value="both" selected>両方</option>
      </select>
    </div>
    <div>
      <label for="fretCount">フレット数（12〜24）</label>
      <select id="fretCount"></select>
    </div>
    <div>
      <label>&nbsp;</label>
      <button id="btnToggleChordTones">コードトーンのみ表示</button>
    </div>
    <!-- ▼ 追加：コードトーンの“直下”にドラッグ消しゴムボタンを配置 -->
    <div>
      <label>&nbsp;</label>
      <button id="btnToggleDragErase" title="マウス/タッチでなぞって非表示（ショートカット: E）">ドラッグ消しゴム：OFF</button>
    </div>
    <div>
      <label>&nbsp;</label>
      <button id="btnExportPdf">PDFで保存</button>
    </div>
    <div>
      <label>&nbsp;</label>
      <div style="display:flex; gap:8px;">
        <button id="btnShowAllMain">全表示</button>
        <button id="btnHideAllMain">全消去</button>
        <button id="btnCopyMain">コピー</button>
      </div>
    </div>


  </div>
</header>


<main>
<!-- 上段：全体指板 -->
<div class="card">
  <canvas id="fretboard" width="1400" height="520"></canvas>
  <div class="legend" id="legend"></div>
  <div class="foot">
    クリックでポジションの非表示/再表示（上段/下段ともに）
    <br>
    <br><b><font size="4" color=#00FF00>Ver 2.0.0になりました。多くの改善がされてますので詳しくはReadMeを一読ください。</font></B>
    <br>バージョンアップに伴い、V1.0のJSONやプリセットが乱れて表示される場合がございます。ご了承ください。
    <br>
    <br> Ver 2.0.2 プリセットの順番をドラッグで入れ替えられるようになりました。
    <br> Ver 2.0.3 Bug Bixed
    <br> Ver 2.0.4 JSONファイルのリンクを追加
    <br> Ver 2.0.5 Bug Bixed
    <br> Ver 2.0.6 スケール追加、及び、名称とリストの最適化
  </div>
  <div style="text-align:center; margin-top:6px;">
    <a href="https://github.com/hosinosoraka/guitar-scale-viewer/blob/main/README.md"
       target="_blank" rel="noopener"
       style="color:yellow; font-weight:bold; text-decoration:none;">
       ReadMe
    </a>
  </div>

<div style="text-align:center; margin-top:6px;">
  <a href="https://github.com/hosinosoraka/guitar-scale-viewer/tree/main/JSON"
     target="_blank" rel="noopener"
     style="color:yellow; font-weight:bold; text-decoration:none;">
     作者が作成したJSONのダウンロードはこちら（随時追加します）
  </a>
</div>

</div>

  <!-- プリセット保存/読み込み -->
  <div class="card">
    <div class="toolbar" style="grid-template-columns: 1fr 1fr; padding:0; max-width:unset;">
      <div>
        <label for="presetName">プリセット名</label>
        <input id="presetName" type="text" list="presetNames" placeholder="例）Cメジャー_7ポジ_v1" />
        <datalist id="presetNames"></datalist>
        <div class="notice">同名で保存すると上書きします（キー/スケール/フレット/ラベル表示/各キャンバスの非表示/ポジション名を保存）。</div>
      </div>
      <div>
        <label>&nbsp;</label>
        <div style="display:flex; gap:8px;">
          <button id="btnSavePreset">この状態を保存</button>
          <button id="btnExportPreset">JSONを書き出し</button>
          <button id="btnImportPreset">JSONを読み込み</button>
          <input id="importFile" type="file" accept=".json,application/json" style="display:none;">
        </div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <details id="presetDropdown" class="dropdown">
        <summary>ローカル保存済みプリセット ▾</summary>
        <div id="presetList" class="menu"><div class="empty">（保存されたプリセットはありません）</div></div>
      </details>
    </div>

    <div class="notice" id="presetMeta"></div>
  </div>




  <!-- 下段：8ポジション（名前は編集可） -->
  <section class="positions" id="positions">

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-I" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-6-I" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-6-I" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-6-I" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-6-I" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-6-I" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-6-I" class="icon-btn btnPasteBoard">ペースト</button></div>

      </div>
      <canvas class="pos-canvas" id="pos-6-I"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-M" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-6-M" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-6-M" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-6-M" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-6-M" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-6-M" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-6-M" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-6-M"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-P" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-6-P" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-6-P" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-6-P" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-6-P" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-6-P" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-6-P" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-6-P"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-5-I" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-5-I" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-5-I" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-5-I" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-5-I" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-5-I" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-5-I" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-5-I"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-5-M" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-5-M" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-5-M" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-5-M" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-5-M" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-5-M" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-5-M" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-5-M"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-5-P" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-5-P" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-5-P" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-5-P" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-5-P" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-5-P" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-5-P" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-5-P"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-4-I" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-4-I" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-4-I" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-4-I" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-4-I" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-4-I" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-4-I" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-4-I"></canvas>
    </div>

    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-4-M" spellcheck="false" title="クリックして名前を編集"></span>
<div class="pos-actions">
  <button data-pos="pos-4-M" data-delta="-1" class="icon-btn btnShiftOne">SHIFT -1</button>
  <button data-pos="pos-4-M" data-delta="1"  class="icon-btn btnShiftOne">SHIFT +1</button>
  <button data-pos="pos-4-M" class="icon-btn btnShowAll">全表示</button>
  <button data-pos="pos-4-M" class="icon-btn btnHideAll">全消去</button>
  <button data-pos="pos-4-M" class="icon-btn btnCopyBoard">コピー</button>
  <button data-pos="pos-4-M" class="icon-btn btnPasteBoard">ペースト</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-4-M"></canvas>
    </div>

  </section>

</main>

<script>
  if (typeof window.showMap === 'undefined') window.showMap = {};
/* ===== 基本設定 ===== */
  const STRINGS = 6;
  const NOTE_RADIUS = 18;  // PC
  const INLAY_R = 5.5, INLAY_R_12 = 6.5;
  const LABEL_OFFSET_FACTOR = 0.42;
  function getNoteRadius(){ return (window.innerWidth <= 768) ? NOTE_RADIUS * 0.7 : NOTE_RADIUS; }
  let dpr = 1; function syncDPR(){ dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1)); }

  /* デフォルトのポジション名 */
  const POSITION_IDS = ['pos-6-I','pos-6-M','pos-6-P','pos-5-I','pos-5-M','pos-5-P','pos-4-I','pos-4-M'];
  const DEFAULT_TITLES = {
    'pos-6-I':'タイトル１ クリックで変更できます。（例　Ｃメジャースケール）等',
    'pos-6-M':'タイトル２ （例　6弦スタート｜人差し指）等',
    'pos-6-P':'タイトル３',
    'pos-5-I':'タイトル４',
    'pos-5-M':'タイトル５',
    'pos-5-P':'タイトル６',
    'pos-4-I':'タイトル７',
    'pos-4-M':'タイトル８',
  };

  /* 下段ボードの独立状態（キー／スケール） */
  const BOARD_STATE = {};
  POSITION_IDS.forEach(id => {
    // 初期状態はChromatic Scale (All Notes)n（キーは C で固定）
    BOARD_STATE[id] = { key: 'C', scale: 'Chromatic Scale (All Notes)' };
  });

  function getBoardKey(id){ return (BOARD_STATE[id] && BOARD_STATE[id].key) || 'C'; }
  function getBoardScale(id){ return (BOARD_STATE[id] && BOARD_STATE[id].scale) || 'Chromatic Scale (All Notes)'; }
  function setBoardKey(id, key){ if (BOARD_STATE[id]) BOARD_STATE[id].key = key; }
  function setBoardScale(id, scale){ if (BOARD_STATE[id]) BOARD_STATE[id].scale = scale; }




  /* 音名・スケール */
  const N_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const N_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
  const KEYS    = [...N_SHARP];
  const SCALES = {

    // --- 全表示 ---
    "Chromatic Scale (All Notes)": { intervals:[0,1,2,3,4,5,6,7,8,9,10,11], degrees:["1","b9th","9th","m3","3","11th","b5/#11","5","b13","13th","m7","7"] },
    // --- Major 系 ---
    "Major (Ionian)": { intervals:[0,2,4,5,7,9,11], degrees:["1","9th","3","11th","5","13th","7"] },
    "Dorian":           { intervals:[0,2,3,5,7,9,10], degrees:["1","9th","m3","11th","5","13th","m7"] },
    "Phrygian":         { intervals:[0,1,3,5,7,8,10], degrees:["1","b9th","m3","11th","5","b13th","m7"] },
    "Lydian":           { intervals:[0,2,4,6,7,9,11], degrees:["1","9th","3","#11th","5","13th","7"] },
    "Mixolydian":       { intervals:[0,2,4,5,7,9,10], degrees:["1","9th","3","11th","5","13th","m7"] },
    "Natural Minor (Aeolian)": { intervals:[0,2,3,5,7,8,10], degrees:["1","9th","m3","11th","5","b13th","m7"] },
    "Locrian":          { intervals:[0,1,3,5,6,8,10], degrees:["1","b9th","m3","11th","b5","b13th","m7"] },

    // --- Melodic Minor 系 ---
    "Melodic Minor":  { intervals:[0,2,3,5,7,9,11], degrees:["1","9th","m3","11th","5","13th","7"] },
    "Dorian b2":        { intervals:[0,1,3,5,7,9,10], degrees:["1","b9th","m3","11th","5","13th","m7"] },
    "Lydian #5 (Lydian Augmented)":        { intervals:[0,2,4,6,8,9,11], degrees:["1","9th","3","#11th","#5","13th","7"] },
    "Lydian b7 (Lydian Dominant)":        { intervals:[0,2,4,6,7,9,10], degrees:["1","9th","3","#11th","5","13th","m7"] },
    "Mixolydian b6":   { intervals:[0,2,4,5,7,8,10], degrees:["1","9th","3","11th","5","b13th","m7"] },
    "Aeolian b5":       { intervals:[0,2,3,5,6,8,10], degrees:["1","9th","m3","11th","b5","b13th","m7"] },
    "Altered Scale (Super Locrian)": { intervals:[0,1,3,4,6,8,10], degrees:["1","b9th","#9th","3","#11th","b13th","m7"] },

    // --- Harmonic Minor 系 ---
    "Harmonic Minor": {   intervals:[0,2,3,5,7,8,11],   degrees:["1","9th","m3","11th","5","b13th","7"] },
    "Locrian natural 6": {   intervals:[0,1,3,5,6,9,10],   degrees:["1","b9th","m3","11th","b5","13th","m7"] },
    "Ionian #5": {   intervals:[0,2,4,5,8,9,11],   degrees:["1","9th","3","11th","#5","13th","7"] },
    "Dorian #4": {   intervals:[0,2,3,6,7,9,10],   degrees:["1","9th","m3","#11th","5","13th","m7"] },
    "Mixolydian b9 b13 (HP5)": {   intervals:[0,1,4,5,7,8,10],   degrees:["1","b9th","3","11th","5","b13th","m7"] },
    "Lydian #2": {   intervals:[0,3,4,6,7,9,11],   degrees:["1","#9th","3","#11th","5","13th","7"]  },
    "Altered Dominant bb7 (Super Locrian)": {   intervals:[0,1,3,4,6,8,9],    degrees:["1","b9th","#9th","3","b5","b13th","bb7"] },

    // --- Diminished ---
    "Combination Diminished (Half–Whole)": { intervals:[0,1,3,4,6,7,9,10], degrees:["1","b9th","#9th","3","b5","5","13th","m7"] },
    "Diminished (Whole–Half)":             { intervals:[0,2,3,5,6,8,9,11], degrees:["1","9th","#9th","11th","b5","b13th","13th","7"] },

    // --- Symmetric (Augmented) ---
    "Augmented Scale":       { intervals:[0,3,4,7,8,11], degrees:["1","m3","3","5","b13th","7"] },

    // --- Pentatonic / Blues ---
    "Major Pentatonic": { intervals:[0,2,4,7,9],    degrees:["1","9th","3","5","13th"] },
    "Minor Pentatonic": { intervals:[0,3,5,7,10],   degrees:["1","m3","11th","5","m7"] },
    "Major Blues Scale": { intervals:[0,2,3,4,7,9], degrees:["1","9th","m3","3","5","13th"] },
    "Minor Blues Scale": { intervals:[0,3,5,6,7,10], degrees:["1","m3","11th","b5","5","m7"] },

    // --- Additional Pentatonic Variants ---
    "Dorian Pentatonic":     { intervals:[0,2,3,7,10], degrees:["1","9th","m3","5","m7"] },
    "Mixolydian Pentatonic": { intervals:[0,2,4,7,10], degrees:["1","9th","3","5","m7"] },

    // --- Jazz Oriented ---
    "Harmonic Major":       { intervals:[0,2,4,5,7,8,11], degrees:["1","9th","3","11th","5","b13th","7"] },
    "Double Harmonic Major":{ intervals:[0,1,4,5,7,8,11], degrees:["1","b9th","3","11th","5","b13th","7"] },
    "Whole Tone Scale":     { intervals:[0,2,4,6,8,10],   degrees:["1","9th","3","#11th","#5","m7"] },
    "Enigmatic Scale":      { intervals:[0,1,4,6,8,10,11],degrees:["1","b9th","3","#11th","#5","m7","7"] },

    // --- Bebop Scales ---
    "Bebop Major Scale":     { intervals:[0,2,4,5,7,8,9,11],  degrees:["1","9th","3","11th","5","#5","13th","7"] },
    "Bebop Dominant Scale":  { intervals:[0,2,4,5,7,9,10,11], degrees:["1","9th","3","11th","5","13th","m7","7"] },
    "Bebop Minor Scale":     { intervals:[0,2,3,5,7,9,10,11], degrees:["1","9th","m3","11th","5","13th","m7","7"] },

    // --- World Scales ---
    "Hungarian Minor":       { intervals:[0,2,3,6,7,8,11], degrees:["1","9th","m3","#11th","5","b13th","7"] },
    "Neapolitan Minor":      { intervals:[0,1,3,5,7,8,11], degrees:["1","b9th","m3","11th","5","b13th","7"] },
    "Neapolitan Major":      { intervals:[0,1,3,5,7,9,11], degrees:["1","b9th","m3","11th","5","13th","7"] },
    "Persian Scale":           { intervals:[0,1,4,5,6,8,11], degrees:["1","b9th","3","11th","b5","b13th","7"] },
    "Arabian Scale":           { intervals:[0,2,4,5,6,8,10], degrees:["1","9th","3","11th","b5","b13th","m7"] },
    "Raga Todi":               { intervals:[0,1,3,6,7,8,11], degrees:["1","b9th","m3","#11th","5","b13th","7"] },
    "Japanese Scale (In Sen)": { intervals:[0,1,5,7,10], degrees:["1","b9th","11th","5","m7"] },
    "Japanese Scale (In)":     { intervals:[0,1,5,7,8],  degrees:["1","b9th","11th","5","b13th"] },
    "Japanese Scale (Yo)":     { intervals:[0,2,5,7,9],  degrees:["1","9th","11th","5","13th"] },

  };

  
// === Scale select grouping (optgroup) ===
const SCALE_GROUPS = {
  "Utility": [
    "Chromatic Scale (All Notes)"
  ],

  "Major (Diatonic Modes)": [
    "Major (Ionian)", "Dorian", "Phrygian", "Lydian",
    "Mixolydian", "Natural Minor (Aeolian)", "Locrian"
  ],

  "Melodic Minor Modes": [
    "Melodic Minor", "Dorian b2",
    "Lydian #5 (Lydian Augmented)",
    "Lydian b7 (Lydian Dominant)",
    "Mixolydian b6", "Aeolian b5",
    "Altered Scale (Super Locrian)"
  ],

  "Harmonic Minor Modes": [
    "Harmonic Minor", "Locrian natural 6",
    "Ionian #5", "Dorian #4",
    "Mixolydian b9 b13 (HP5)",
    "Lydian #2",
    "Altered Dominant bb7 (Super Locrian)"
  ],

  "Symmetric (Diminished)": [
    "Combination Diminished (Half–Whole)",
    "Diminished (Whole–Half)"
  ],

  "Symmetric (Augmented)": [
    "Augmented Scale"
  ],

  "Pentatonic / Blues": [
    "Major Pentatonic", "Minor Pentatonic",
    "Major Blues Scale", "Minor Blues Scale",
    "Dorian Pentatonic", "Mixolydian Pentatonic"
  ],

  "Jazz Oriented": [
    "Harmonic Major", "Double Harmonic Major",
    "Whole Tone Scale", "Enigmatic Scale",
    "Bebop Major Scale", "Bebop Dominant Scale", "Bebop Minor Scale"
  ],

  "World Scales": [
    "Hungarian Minor", "Neapolitan Minor", "Neapolitan Major",
    "Persian Scale", "Arabian Scale", "Raga Todi",
    "Japanese Scale (In Sen)", "Japanese Scale (In)", "Japanese Scale (Yo)"
  ]
};



  // スケールセレクトを構築
  function populateScaleSelect(scaleSel, groups = SCALE_GROUPS){
    if (!scaleSel) return;
    scaleSel.innerHTML = '';
    for (const [label, keys] of Object.entries(groups)){
      const og = document.createElement('optgroup');
      og.label = label;
      keys.forEach(key => {
        const opt = document.createElement('option');
        opt.value = key;   // 内部値はSCALESのキー
        opt.textContent = key; // 表示もキー名そのまま
        og.appendChild(opt);
      });
      scaleSel.appendChild(og);
    }
  }
const TUNING = ["E","B","G","D","A","E"]; // 1弦→6弦

  /* ===== DOM ===== */
  const keySel = document.getElementById('keySelect');
  const scaleSel = document.getElementById('scaleSelect');
  const labelModeSel = document.getElementById('labelMode');
  const fretSel = document.getElementById('fretCount');
  const resetHiddenMain = document.getElementById('resetHiddenMain');
  const mainCanvas = document.getElementById('fretboard');
  const mainCtx = mainCanvas.getContext('2d');

  const presetNameInput = document.getElementById('presetName');
  const presetNamesDatalist = document.getElementById('presetNames');
  const presetDropdown = document.getElementById('presetDropdown');
  const presetList = document.getElementById('presetList');
  const presetMeta = document.getElementById('presetMeta');
  const btnSavePreset = document.getElementById('btnSavePreset');
  const btnExportPreset = document.getElementById('btnExportPreset');
  const btnImportPreset = document.getElementById('btnImportPreset');
  const importFile = document.getElementById('importFile');
  // ▼ 7ポジ 横シフト：hiddenMap の座標を ±1 ずらし、キーも ±1 変更

function shiftPositionsMask(delta){
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
  POSITION_IDS.forEach(id => {
    const src = hiddenMap[id];
    const dst = new Set();
    if (!src) return;

    // 既存の非表示マスクを ±1 フレットに平行移動
    src.forEach(key => {
      const m = /^(\d+):(\d+)$/.exec(key);
      if(!m) return;
      const s = parseInt(m[1], 10);
      const f2 = parseInt(m[2], 10) + delta;
      if (f2 < 0 || f2 > frets) return; // 範囲外は捨てる
      dst.add(`${s}:${f2}`);
    });

    // ★ 新しく入ってくる端の列を最初から「非表示」に追加
    if (delta !== 0){
      const enteringFret = (delta > 0) ? 0 : frets; // +1なら0F、-1なら最終Fが“新規入場”
      for (let s = 0; s < STRINGS; s++){
        dst.add(`${s}:${enteringFret}`);
      }
    }

    hiddenMap[id] = dst;
  });
}

  function stepKey(delta){
    const keys = KEYS;
    let idx = keys.indexOf(keySel.value);
    if (idx < 0) idx = 0;
    keySel.value = keys[(idx + delta + 12) % 12];
  }
  function onPosShift(delta){
    shiftPositionsMask(delta); // シェイプを物理的に1フレット移動
    stepKey(delta);            // UIのキーも ±1 進める
    drawAll();                 // リセットはしない（隠し状態維持）
  }
  document.getElementById('btnPosShiftUp')?.addEventListener('click', ()=> onPosShift(+1));
  document.getElementById('btnPosShiftDown')?.addEventListener('click', ()=> onPosShift(-1));

// コードトーントグル（メインのみ再描画する）
const btnToggleChord = document.getElementById('btnToggleChordTones');
btnToggleChord?.addEventListener('click', () => {
  chordTonesOnly = !chordTonesOnly;
  btnToggleChord.textContent = chordTonesOnly ? 'コードトーン再表示' : 'コードトーンのみ表示';
  // 下段8ボードは影響させない：メインのみ再描画
  drawMain();
});



  // 下段ポジション名の要素
  const posNameEls = {};
  document.querySelectorAll('.pos-name').forEach(el => { posNameEls[el.dataset.pos] = el; });

// セレクト初期化
KEYS.forEach(k=>{ const o=document.createElement('option'); o.value=o.textContent=k; keySel.appendChild(o); });
populateScaleSelect(scaleSel);
for (let f=12; f<=24; f++){ const o=document.createElement('option'); o.value=String(f); o.textContent=String(f); fretSel.appendChild(o); }

// ★ 起動直後は Chromatic Scale (All Notes) にする（メイン）
keySel.value = 'C';
scaleSel.value = 'Chromatic Scale (All Notes)';
fretSel.value = '24';


  // デフォルト名を反映
  function applyDefaultTitles(){
    Object.entries(DEFAULT_TITLES).forEach(([id, name])=>{
      if (posNameEls[id]) posNameEls[id].textContent = name;
    });
  }

  // 非表示セット（メインは空、下段は初期状態で「全ポジション非表示」）
  const hiddenMap = { main:new Set() }; POSITION_IDS.forEach(id=> hiddenMap[id]=new Set());

// 強制表示（showMap）の初期化
const showMap = { main:new Set() }; POSITION_IDS.forEach(id => showMap[id] = new Set());

  // コピー＆ペースト用クリップボード
  let clipboardBoard = null;


  // 指定ボードの全マス（弦 × 0〜frets）を非表示にするヘルパ
  function hideAllPositionsForBoard(mapKey){
    const frets = Math.max(12, Math.min(24, parseInt((document.getElementById('fretCount')?.value)||'16')));
    const set = hiddenMap[mapKey];
    set.clear();
    for (let s = 0; s < STRINGS; s++){
      for (let f = 0; f <= frets; f++){
        set.add(`${s}:${f}`);
      }
    }
  }

  function resetBoardState(mapKey, {clearHidden=false, clearForced=false}={}){
    if (clearHidden) hiddenMap[mapKey]?.clear();
    if (clearForced) showMap[mapKey]?.clear();
  }



  /* === コードトーン表示トグル === */
let chordTonesOnly = false;
function isChordToneInterval(interval){
  return interval === 0 || interval === 3 || interval === 4 || interval === 7 || interval === 10 || interval === 11;
}

/* ===== 共通描画ユーティリティ ===== */
  const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  function styleSnapshot(){
    return {
      board1: css('--board1'), board2: css('--board2'),
      nut: css('--nut'), fret: css('--fret'), string: css('--string'),
      posBorder: css('--pos-border'), labelInk: css('--label-ink'),
      muted: css('--muted'),
      degRoot: css('--deg-root'), degThird: css('--deg-third'),
      degFifth: css('--deg-fifth'), degSeventh: css('--deg-seventh'),
      degOther: css('--deg-other'), degBlues: css('--deg-blues')
    };
  }
  function roundRect(ctx, x, y, w, h, r){
    if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
  }
  function degreeColor(i, S){
    if (i===0) return S.degRoot;
    if (i===3||i===4) return S.degThird;
    if (i===7) return S.degFifth;
    if (i===10||i===11) return S.degSeventh;
    if (i===6) return S.degBlues;
    return S.degOther;
  }
  function drawNote(ctx, cx, cy, r, pc, root, degreeText, mode, keyName, S){
    const interval = (pc - root + 12) % 12;
    const fill = degreeColor(interval, S);
    const flats = ['F','Bb','Eb','Ab','Db','Gb','Cb'].includes(keyName);
    const noteName = (flats?N_FLAT:N_SHARP)[pc];

    ctx.fillStyle = fill;
    ctx.strokeStyle = S.posBorder;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    ctx.fillStyle = S.labelInk;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

    if (mode === 'note'){
      ctx.font = `bold ${Math.round(r*0.75)}px system-ui`;
      ctx.fillText(noteName, cx, cy);
    } else if (mode === 'degree'){
      ctx.font = `bold ${Math.round(r*0.75)}px system-ui`;
      ctx.fillText(degreeText || '', cx, cy);
    } else {
      const dy = r * LABEL_OFFSET_FACTOR;
      ctx.font = `bold ${Math.round(r*0.68)}px system-ui`;
      ctx.fillText(degreeText || '', cx, cy - dy);
      ctx.font = `bold ${Math.round(r*0.68)}px system-ui`;
      ctx.fillText(noteName,       cx, cy + dy);
    }
  }
  function layoutOn(ctx, canvasEl, strings, frets, S){
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    ctx.clearRect(0,0,w,h);
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;

    const boardX = 20, boardW = w - 40;
    const R = 16;
    const grd = ctx.createLinearGradient(0, fbY, 0, fbY + fbH);
    grd.addColorStop(0, S.board1); grd.addColorStop(1, S.board2);
    ctx.fillStyle = grd;
    roundRect(ctx, boardX, fbY, boardW, fbH, R); ctx.fill();
    ctx.strokeStyle = '#1f2432'; ctx.lineWidth = 1; ctx.stroke();

    ctx.fillStyle = S.nut; ctx.fillRect(baseX - 10, fbY, 10, fbH);

    ctx.strokeStyle = S.fret; ctx.lineWidth = 2;
    for(let f=1; f<=frets; f++){
      const x = baseX + fbW * (f / frets);
      ctx.beginPath(); ctx.moveTo(x, fbY); ctx.lineTo(x, fbY + fbH); ctx.stroke();
    }

    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    ctx.fillStyle = S.muted; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
    const footY = fbY + fbH + 16; ctx.fillText('0', openCx, footY);
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      ctx.fillText(String(f), (prevX + thisX)/2, footY);
    }

    ctx.fillStyle = '#3b80ff66';
    [3,5,7,9,12,15,17,19,21,24].forEach(f=>{
      if (f>frets) return;
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      const xCenter = (prevX + thisX) / 2;
      if (f%12===0){
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.33, INLAY_R_12, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.66, INLAY_R_12, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.5, INLAY_R, 0, Math.PI*2); ctx.fill();
      }
    });

    for(let s=0; s<strings; s++){
      const y = fbY + fbH * (s+0.5)/strings;
      ctx.strokeStyle = S.string; ctx.lineWidth = 1 + (strings - s)*0.4;
      ctx.beginPath(); ctx.moveTo(baseX, y); ctx.lineTo(baseX + fbW, y); ctx.stroke();
    }

    return {fbY, fbH, baseX, fbW, openCx};
  }
  function buildScale(root, name){
    const {intervals, degrees} = SCALES[name];
    const pcs = new Set(intervals.map(i => (root + i) % 12));
    const degreeMap = new Map(); intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));
    return {pcs, degreeMap};
  }

// スケール外のときは AChromatic Scale (All Notes) の度数にフォールバック
function getDegreeTextFor(pc, root, scaleName, degreeMap){
  const interval = (pc - root + 12) % 12;
  if (degreeMap && degreeMap.has(pc)) return degreeMap.get(pc);
  const ap = SCALES['Chromatic Scale (All Notes)'];
  if (ap && Array.isArray(ap.degrees) && ap.degrees[interval]) return ap.degrees[interval];
  return String(interval); // 念のため
}


  /* ===== 上段描画 ===== */
  function drawMain(){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const root = KEYS.indexOf(keySel.value);
    const scaleName = scaleSel.value;
    const labelMode = labelModeSel.value;

    const cssW = mainCanvas.clientWidth|0, cssH = mainCanvas.clientHeight|0;
    mainCanvas.width = Math.floor(cssW * dpr); mainCanvas.height = Math.floor(cssH * dpr);
    mainCtx.setTransform(dpr,0,0,dpr,0,0);

    const S = styleSnapshot();
    const g = layoutOn(mainCtx, mainCanvas, STRINGS, frets, S);
    const {pcs, degreeMap} = buildScale(root, scaleName);
    const r = getNoteRadius();

    for(let s=0; s<STRINGS; s++){
      const openPc = N_SHARP.indexOf(TUNING[s]);
      const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;

const pc0 = openPc % 12;
const k0 = `${s}:0`;
const interval0 = (pc0 - root + 12) % 12;
const forced0 = (showMap.main && showMap.main.has(k0));
if (forced0 || (!hiddenMap.main.has(k0) && pcs.has(pc0) && (!chordTonesOnly || isChordToneInterval(interval0)))) {
// 0フレット（開放）側
drawNote(mainCtx, g.openCx, cy, r, pc0, root, getDegreeTextFor(pc0, root, scaleName, degreeMap), labelMode, keySel.value, S);
}

      for(let f=1; f<=frets; f++){
        const prevX = g.baseX + g.fbW * ((f-1)/frets);
        const thisX = g.baseX + g.fbW * (f/frets);
        const cx = (prevX + thisX)/2;
const pc = (openPc + f) % 12;
const k = `${s}:${f}`;
const interval = (pc - root + 12) % 12;
const forced = (showMap.main && showMap.main.has(k));
if (forced || (!hiddenMap.main.has(k) && pcs.has(pc) && (!chordTonesOnly || isChordToneInterval(interval)))) {
// 1〜最終フレット側
drawNote(mainCtx, cx,       cy, r, pc,  root, getDegreeTextFor(pc,  root, scaleName, degreeMap), labelMode, keySel.value, S);
}
      }
    }

    const legend = document.getElementById('legend');
    legend.innerHTML = `
      <span class="chip"><span class="dot" style="background:var(--deg-root)"></span>ルート(1)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-third)"></span>3度(m3/M3)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-fifth)"></span>5度</span>
      <span class="chip"><span class="dot" style="background:var(--deg-seventh)"></span>7度(m7/M7)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-other)"></span>その他スケール音</span>
      <span class="chip"><span class="dot" style="background:var(--deg-blues)"></span>ブルーノート</span>
      <span>キー: <b>${keySel.value}</b></span>
      <span>スケール: <b>${scaleSel.value}</b></span>
      <span>ラベル: <b>${labelModeSel.options[labelModeSel.selectedIndex].textContent}</b></span>
    `;
  }
  mainCanvas.addEventListener('click', (ev)=>{
    const rect = mainCanvas.getBoundingClientRect();
    toggleHiddenAtPoint('main', mainCanvas, ev.clientX - rect.left, ev.clientY - rect.top, drawMain);
  });
// 上段（メイン）の全表示／全消去
const btnShowAllMain = document.getElementById('btnShowAllMain');
const btnHideAllMain = document.getElementById('btnHideAllMain');

btnShowAllMain?.addEventListener('click', ()=>{
hiddenMap.main.clear();      // 全表示＝非表示マスクを空に
showMap.main?.clear();       // ★ “強制表示”もリセット（表示条件を純粋に）
  drawMain();
});

btnHideAllMain?.addEventListener('click', ()=>{
hideAllPositionsForBoard('main'); // 全消去＝全マス非表示
showMap.main?.clear();            // ★ 強制表示もクリア
  drawMain();
});

/* ===== 下段：8枚描画（各ボードは独立した key/scale を使用） ===== */
function drawOnePos(canvasId){
  const el = document.getElementById(canvasId);
  if (!el) return;

  const ctx = el.getContext('2d', { alpha:true });
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));

  // ▼ 下段ボードはメインと独立した key/scale を参照
  const boardKey = getBoardKey(canvasId);
  const boardScale = getBoardScale(canvasId);

  const root = KEYS.indexOf(boardKey);
  const scaleName = boardScale;
  const labelMode = labelModeSel.value;

  const cssW = el.clientWidth|0, cssH = el.clientHeight|0;
  el.width = Math.floor(cssW * dpr); el.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const S = styleSnapshot();
  const g = layoutOn(ctx, el, STRINGS, frets, S);

  // ▼ スケールの音（pcs）を“描画条件”にも使う（※下段はコードトーンON/OFFは無視）
  const {intervals, degrees} = SCALES[scaleName];
  const pcs = new Set(intervals.map(i => (root + i) % 12));
  const degreeMap = new Map();
  intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));

  const r = getNoteRadius();

  for (let s = 0; s < STRINGS; s++){
    const openPc = N_SHARP.indexOf(TUNING[s]);
    const cy = g.fbY + g.fbH * (s + 0.5) / STRINGS;

    // 0フレット（開放）
    const pc0 = openPc % 12;
    const k0 = `${s}:0`;
    const forced0 = (showMap[canvasId] && showMap[canvasId].has(k0));
if (forced0 || (!hiddenMap[canvasId].has(k0) && pcs.has(pc0))) {
drawNote(ctx, g.openCx, cy, r, pc0, root, getDegreeTextFor(pc0, root, scaleName, degreeMap), labelMode, boardKey, S);
    }

    // 1〜最終フレット
    for (let f = 1; f <= frets; f++){
      const prevX = g.baseX + g.fbW * ((f - 1) / frets);
      const thisX = g.baseX + g.fbW * (f / frets);
      const cxX = (prevX + thisX) / 2;
      const pc = (openPc + f) % 12;
      const k = `${s}:${f}`;
      const forced = (showMap[canvasId] && showMap[canvasId].has(k));
if (forced || (!hiddenMap[canvasId].has(k) && pcs.has(pc))) {
// 1〜最終フレット側
drawNote(ctx, cxX,      cy, r, pc,  root, getDegreeTextFor(pc,  root, scaleName, degreeMap), labelMode, boardKey, S);
      }
    }
  }
}



  function drawPositions(){ POSITION_IDS.forEach(id => drawOnePos(id)); }
  POSITION_IDS.forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener('click', (ev)=>{
      const rect = el.getBoundingClientRect();
      toggleHiddenAtPoint(id, el, ev.clientX - rect.left, ev.clientY - rect.top, ()=>drawOnePos(id));
    });
  });
// 下段カードの「全表示／全消去」デリゲート
document.addEventListener('click', (e)=>{
  const btnShow = e.target.closest('.btnShowAll');
  if (btnShow){
    const id = btnShow.getAttribute('data-pos');
    if (id && hiddenMap[id]){
      hiddenMap[id].clear();       // 全表示＝非表示マスクを空に
      showMap[id]?.clear();      // ★ 下段も強制表示をリセット
      drawOnePos(id);
    }
    return;
  }
  const btnHide = e.target.closest('.btnHideAll');
  if (btnHide){
    const id = btnHide.getAttribute('data-pos');
    if (id && hiddenMap[id]){
      hideAllPositionsForBoard(id); // 全消去＝全マスを非表示に
      showMap[id]?.clear();      // ★ 下段の強制表示をクリア
      drawOnePos(id);
    }
    return;
  }
});

// ==== コピー／ペースト ====

// （新規）メインで実際に非表示となるセル（手動＋スケール外＋コードトーン外）を収集
function collectEffectiveHiddenForMain(){
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value || '16')));
  const root = KEYS.indexOf(keySel.value);
  const { intervals } = SCALES[scaleSel.value];
  const pcs = new Set(intervals.map(i => (root + i) % 12));

  const effective = new Set(hiddenMap.main); // 手動で隠した分をベースに

  for (let s = 0; s < STRINGS; s++){
    const openPcBase = N_SHARP.indexOf(TUNING[s]);
    const openPc = openPcBase % 12;

    // 0フレット（開放）
    {
      const k0 = `${s}:0`;
      const interval0 = (openPc - root + 12) % 12;
      const forced0 = (window.showMap && showMap.main && showMap.main.has(k0));
      const visible0 = forced0 || (pcs.has(openPc) && (!chordTonesOnly || isChordToneInterval(interval0)));
      if (!visible0) effective.add(k0);
    }

    // 1〜最終フレット
    for (let f = 1; f <= frets; f++){
      const pc = (openPcBase + f) % 12;
      const k  = `${s}:${f}`;
      const interval = (pc - root + 12) % 12;
      const forced = (window.showMap && showMap.main && showMap.main.has(k));
      const visible = forced || (pcs.has(pc) && (!chordTonesOnly || isChordToneInterval(interval)));
      if (!visible) effective.add(k);
    }
  }
  return effective;
}

// メインのコピー（実描画ベースの非表示セルを保存）
document.getElementById('btnCopyMain')?.addEventListener('click', ()=>{
  const effectiveHidden = collectEffectiveHiddenForMain();
  clipboardBoard = {
    key: keySel.value,
    scale: scaleSel.value,
    hidden: Array.from(effectiveHidden)
  };
  alert('メインをコピーしました');
});



// 下段カードのコピー／ペースト（デリゲート）
document.addEventListener('click', (e)=>{
  const btnCopy = e.target.closest('.btnCopyBoard');
  if (btnCopy){
    const id = btnCopy.getAttribute('data-pos');
    clipboardBoard = {
      key: getBoardKey(id),
      scale: getBoardScale(id),
      hidden: Array.from(hiddenMap[id])
    };
    alert(`${id} をコピーしました`);
    return;
  }

  const btnPaste = e.target.closest('.btnPasteBoard');
  if (btnPaste){
    if (!clipboardBoard){ alert('コピーされていません'); return; }
    const id = btnPaste.getAttribute('data-pos');
    setBoardKey(id, clipboardBoard.key);
    setBoardScale(id, clipboardBoard.scale);
    hiddenMap[id] = new Set(clipboardBoard.hidden);
    showMap[id]?.clear();        // ★ 既存の強制表示は無効化
    drawOnePos(id);
    alert(`${id} にペーストしました`);
    return;
  }
});


// 単一ボードの SHIFT（キー±1・非表示マスクを±1フレット移動）
function shiftBoard(boardId, delta){
  const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));

  // 1) 非表示マスクを ±1 フレットに平行移動
  const src = hiddenMap[boardId];
  if (!src) return;
  const dst = new Set();
  src.forEach(key => {
    const m = /^(\d+):(\d+)$/.exec(key);
    if(!m) return;
    const s = parseInt(m[1], 10);
    const f2 = parseInt(m[2], 10) + delta;
    if (f2 < 0 || f2 > frets) return;
    dst.add(`${s}:${f2}`);
  });

  // ★ 新しく入ってくる端の列を最初から「非表示」に追加
  if (delta !== 0){
    const enteringFret = (delta > 0) ? 0 : frets;
    for (let s = 0; s < STRINGS; s++){
      dst.add(`${s}:${enteringFret}`);
    }
  }

  hiddenMap[boardId] = dst;

  // 2) ボード専用キーを ±1（scale は維持）
  const curKey = getBoardKey(boardId);
  let idx = KEYS.indexOf(curKey);
  if (idx < 0) idx = 0;
  const nextKey = KEYS[(idx + delta + 12) % 12];
  setBoardKey(boardId, nextKey);

  // 3) 再描画
  drawOnePos(boardId);
}

// 下段カード：SHIFT -1 / +1 のイベントデリゲート
document.addEventListener('click', (e)=>{
  const btnShift = e.target.closest('.btnShiftOne');
  if (!btnShift) return;
  const id = btnShift.getAttribute('data-pos');
  const delta = parseInt(btnShift.getAttribute('data-delta')||'0', 10);
  if (!id || !delta) return;
  shiftBoard(id, delta);
});


  function toggleHiddenAtPoint(mapKey, canvasEl, x, y, rerender){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;
    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
    let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

    const centers = [openCx];
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      centers.push( (prevX + thisX)/2 );
    }
    let nearestF = 0, best = Infinity;
    centers.forEach((cx, i) => { const d = Math.abs(cx - x); if (d < best){ best = d; nearestF = i; } });

    const key = `${s}:${nearestF}`;
const boardKey   = (mapKey === 'main') ? keySel.value   : getBoardKey(mapKey);
const boardScale = (mapKey === 'main') ? scaleSel.value : getBoardScale(mapKey);
const root2 = KEYS.indexOf(boardKey);
const pcs2 = new Set((SCALES[boardScale] || SCALES['Chromatic Scale (All Notes)']).intervals.map(i => (root2 + i) % 12));
const pc2 = (N_SHARP.indexOf(TUNING[s]) + nearestF) % 12;
const inScale = pcs2.has(pc2) && (!chordTonesOnly || isChordToneInterval((pc2 - root2 + 12) % 12));
if (inScale){
  const set2 = hiddenMap[mapKey];
  if (set2.has(key)) set2.delete(key); else set2.add(key);
  if (showMap && showMap[mapKey]) showMap[mapKey].delete(key);
} else {
  if (!showMap[mapKey]) showMap[mapKey] = new Set();
  if (showMap[mapKey].has(key)) showMap[mapKey].delete(key);
  else { showMap[mapKey].add(key); hiddenMap[mapKey].delete(key); }
}

    (rerender || (()=>{ drawMain(); drawPositions(); }))();
  }


  // ==== 追加：ドラッグで非表示にする「消しゴム」機能 ====
  function hideAtPoint(mapKey, canvasEl, x, y){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;
    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
    let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

    const centers = [openCx];
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      centers.push( (prevX + thisX)/2 );
    }
    let nearestF = 0, best = Infinity;
    centers.forEach((cx, i) => { const d = Math.abs(cx - x); if (d < best){ best = d; nearestF = i; } });
    const key = `${s}:${nearestF}`;
    hiddenMap[mapKey].add(key);
    if (showMap && showMap[mapKey]) showMap[mapKey].delete(key); // ★ 強制表示は消す
  }

  let dragEraseEnabled = false;
  let isErasing = false;

  function setDragEraseUI(){
    const btn = document.getElementById('btnToggleDragErase');
    if (btn) btn.textContent = 'ドラッグ消しゴム：' + (dragEraseEnabled ? 'ON' : 'OFF');
  }

  function attachDragErase(mapKey, canvasEl, rerender){
    const getXY = (ev) => {
      const rect = canvasEl.getBoundingClientRect();
      return {
        x: (ev.clientX ?? (ev.touches && ev.touches[0]?.clientX) ?? 0) - rect.left,
        y: (ev.clientY ?? (ev.touches[0]?.clientY) ?? 0) - rect.top
      };
    };

    const onDown = (ev) => {
      if (!dragEraseEnabled) return;
      isErasing = true;
      const {x,y} = getXY(ev);
      hideAtPoint(mapKey, canvasEl, x, y);
      (rerender||(()=>{ drawMain(); drawPositions(); }))();
      ev.preventDefault?.();
    };
    const onMove = (ev) => {
      if (!dragEraseEnabled || !isErasing) return;
      const {x,y} = getXY(ev);
      hideAtPoint(mapKey, canvasEl, x, y);
      (rerender||(()=>{ drawMain(); drawPositions(); }))();
      ev.preventDefault?.();
    };
    const onUp = () => { isErasing = false; };

    canvasEl.addEventListener('pointerdown', onDown);
    canvasEl.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    canvasEl.addEventListener('pointerleave', onUp);
    // touch fallback
    canvasEl.addEventListener('touchstart', onDown, {passive:false});
    canvasEl.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);
  }

  // Eキー／ボタンクリックでON/OFF
  document.addEventListener('keydown', (e)=>{
    if (e.key && e.key.toLowerCase() === 'e'){
      dragEraseEnabled = !dragEraseEnabled;
      setDragEraseUI();
    }
  });
  document.getElementById('btnToggleDragErase')?.addEventListener('click', ()=>{
    dragEraseEnabled = !dragEraseEnabled;
    setDragEraseUI();
  });

  function bindAllDragErase(){
    attachDragErase('main', mainCanvas, drawMain);
    POSITION_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) attachDragErase(id, el, ()=>drawOnePos(id));
    });
  }


  /* ===== プリセット（localStorage） ===== */
  const LS_KEY = 'gsv_presets_v1';

  function lsGet(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return [];
      const list = JSON.parse(raw);
      return Array.isArray(list) ? list : [];
    }catch(e){ return []; }
  }
  function lsSet(list){ try{ localStorage.setItem(LS_KEY, JSON.stringify(list)); }catch(e){} }
  function renderPresetNameDatalist(list){
    presetNamesDatalist.innerHTML = '';
    list.forEach(p=>{ const opt = document.createElement('option'); opt.value = p.name; presetNamesDatalist.appendChild(opt); });
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m])); }

function renderPresetDropdown(list){
  presetList.innerHTML = '';
  if (!list.length){
    presetList.innerHTML = `<div class="empty">（保存されたプリセットはありません）</div>`;
    return;
  }

  // 並び順は localStorage の配列順を尊重（ソートしない）
  // DnD中に参照できるように id -> object をマップ化
  const byId = new Map(list.map(p => [String(p.id), p]));

  // 各行を生成（draggable対応）
  list.forEach((p) => {
    const row = document.createElement('div');
    row.className = 'preset-item';
    row.draggable = true;
    row.dataset.id = String(p.id ?? p.name ?? '');

    // ドラッグ開始/終了
    row.addEventListener('dragstart', (e)=>{
      row.classList.add('dragging');
      e.dataTransfer.setData('text/plain', row.dataset.id);
      // 画像のないドラッグ開始を可能に
      if (e.dataTransfer.setDragImage) {
        const img = new Image(); img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB'; 
        e.dataTransfer.setDragImage(img, 0, 0);
      }
    });
    row.addEventListener('dragend', ()=> row.classList.remove('dragging'));

    // ドラッグオーバー：行の前後を判定して入れ替える
    row.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const dragging = presetList.querySelector('.preset-item.dragging');
      if (!dragging || dragging === row) return;
      const rect = row.getBoundingClientRect();
      const offset = e.clientY - rect.top;
      if (offset > rect.height/2) {
        row.after(dragging);
      } else {
        row.before(dragging);
      }
    });

    // 左側（メタ：名前のみ）
    const meta = document.createElement('div'); 
    meta.className = 'preset-meta';
    meta.innerHTML = `<div class="preset-name">${escapeHtml(p.name ?? '')}</div>`;

    // 右側アクション
    const actionsWrap = document.createElement('div'); actionsWrap.className = 'row-actions';
    const loadBtn = document.createElement('button'); loadBtn.className='icon-btn'; loadBtn.textContent='読み込む';
    loadBtn.addEventListener('click', (e)=>{ e.stopPropagation(); applyPreset(p); });

    const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.textContent='🗑'; delBtn.title='削除';
    delBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (confirm(`「${p.name}」を削除しますか？`)) deletePresetFromLocal(p.id);
    });

    actionsWrap.appendChild(loadBtn);
    actionsWrap.appendChild(delBtn);

    row.appendChild(meta);
    row.appendChild(actionsWrap);

    // 行クリックで読み込み
    row.addEventListener('click', ()=> applyPreset(p));

    presetList.appendChild(row);
  });

  // コンテナ側の dragover を許可（ドロップ可能に）
  presetList.addEventListener('dragover', (e)=> e.preventDefault(), { once:false });

  // ドロップ時：DOM順から新しい配列順を保存
  // 複数回 render されてもイベントが増殖しないように先に既存の ondrop を解除
  presetList.ondrop = null;
  presetList.addEventListener('drop', ()=>{
    const ids = Array.from(presetList.querySelectorAll('.preset-item')).map(el => String(el.dataset.id));
    const newOrder = ids.map(id => byId.get(id)).filter(Boolean);
    lsSet(newOrder);
    renderPresetNameDatalist(newOrder);
  }, { once:true });
}

  function loadPresetList(){ const list = lsGet(); renderPresetDropdown(list); renderPresetNameDatalist(list); return list; }

function savePresetToLocal(preset){
  // v2: 8ボードのみ保存。キー/スケールは保存しない
  const only8 = {};
  if (preset.positions && typeof preset.positions === 'object'){
    POSITION_IDS.forEach(id => {
      const p = preset.positions[id];
      if (!p) return;
      only8[id] = {
        hidden: Array.isArray(p.hidden) ? p.hidden : [],
        title:  (typeof p.title === 'string' ? p.title : '')
      };
    });
  } else {
    // v1 相当が来た場合でも、現状DOMから 8ボードの hidden/title を作る
    POSITION_IDS.forEach(id => {
      only8[id] = {
        hidden: Array.from(hiddenMap[id] || []),
        title:  (posNameEls[id]?.textContent ?? '').trim()
      };
    });
  }

  const v2 = {
    version: 2,
    id: preset.id,
    name: preset.name,
    updatedAt: Date.now(),
    frets: parseInt(fretSel.value || '16', 10),
    labelMode: labelModeSel.value,
    positions: only8
  };

  const list = lsGet();
  const idx = list.findIndex(x => x.id === v2.id);
  if (idx >= 0) list[idx] = v2; else list.push(v2);
  lsSet(list);

  renderPresetDropdown(list);
  renderPresetNameDatalist(list);
  presetMeta.textContent = `保存しました: ${v2.name}（8ボードのみ／キー・スケールは保存しません）`;
}

  function deletePresetFromLocal(id){ const list = lsGet().filter(x => x.id !== id); lsSet(list); renderPresetDropdown(list); renderPresetNameDatalist(list); presetMeta.textContent = 'プリセットを削除しました'; }

function currentStateToPreset(name){
  // v2: 8ボードのみ保存。キー/スケールは含めない
  const positions = {};
  POSITION_IDS.forEach(id => {
    positions[id] = {
      hidden: Array.from(hiddenMap[id] || []),
      title: (posNameEls[id]?.textContent ?? '').trim()
    };
  });
  const frets = parseInt(fretSel.value || '16', 10);
  const labelMode = labelModeSel.value;

  return {
    version: 2,
    id: name,
    name,
    updatedAt: Date.now(),
    frets,
    labelMode,
    positions
  };
}

function applyPreset(preset){
  // v2: { positions:{id:{hidden[],title}}, frets, labelMode } だけ使う
  if (preset && preset.positions && typeof preset.positions === 'object'){
    if (typeof preset.frets === 'number')      fretSel.value = String(preset.frets);
    if (typeof preset.labelMode === 'string')  labelModeSel.value = preset.labelMode;

    // 8ボードの hidden/title だけ反映（キー/スケールは無視）
    POSITION_IDS.forEach(id => {
      const p = preset.positions[id];
      if (!p) return;

      hiddenMap[id].clear();
      (Array.isArray(p.hidden) ? p.hidden : []).forEach(v => hiddenMap[id].add(v));

      if (posNameEls[id] && typeof p.title === 'string'){
        const t = p.title.trim();
        if (t) posNameEls[id].textContent = t;
      }
    });

    presetNameInput.value = preset.name || '';
    drawAll();
    presetMeta.textContent = `読み込み: ${preset.name}（8ボードの非表示/名称のみ。キー/スケールは無視）`;
    presetDropdown.open = false;
    return;
  }

  // --- v1 後方互換：キー/スケールは無視する ---
  // frets/labelMode は反映OK
  if (preset && preset.meta){
    if (typeof preset.meta.frets === 'number')     fretSel.value = String(preset.meta.frets);
    if (typeof preset.meta.labelMode === 'string') labelModeSel.value = preset.meta.labelMode;
    // preset.meta.key / preset.meta.scale は無視
  }
  // hidden は従来どおり反映（main/各posともOK）
  if (preset && preset.hidden){
    Object.keys(hiddenMap).forEach(k=>{
      hiddenMap[k].clear();
      (preset.hidden?.[k] || []).forEach(v=> hiddenMap[k].add(v));
    });
  }
  // posTitles もそのまま反映
  if (preset && preset.posTitles && typeof preset.posTitles === 'object') {
    POSITION_IDS.forEach(id => {
      const el = posNameEls[id]; if (!el) return;
      const val = preset.posTitles[id];
      if (typeof val === 'string' && val.trim().length) el.textContent = val.trim();
    });
  }

  presetNameInput.value = preset?.name || '';
  drawAll();
  // メタ表記もキー/スケールを出さない
  presetMeta.textContent = `読み込み: ${preset?.name ?? ''}（キー/スケールは無視）`;
  presetDropdown.open = false;
}

  // 保存/読込ボタン
  btnSavePreset.addEventListener('click', ()=>{ const name = (presetNameInput.value || '').trim(); if (!name){ alert('プリセット名を入力してください'); presetNameInput.focus(); return; } savePresetToLocal( currentStateToPreset(name) ); });
  presetNameInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); btnSavePreset.click(); } });
  btnExportPreset.addEventListener('click', ()=>{
    const name = (presetNameInput.value || 'preset').replace(/[\\/:*?"<>|]/g,'_');
    const preset = currentStateToPreset(name);
    const blob = new Blob([JSON.stringify(preset,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${name}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    presetMeta.textContent = `JSONを書き出しました: ${name}.json`;
  });
  btnImportPreset.addEventListener('click', ()=> importFile.click());
  importFile.addEventListener('change', async ()=>{
    const file = importFile.files && importFile.files[0]; if (!file) return;
    let textRaw = '';
    try{ textRaw = await file.text(); }catch(e){ alert('ファイルの読み込みに失敗: ' + (e && e.message ? e.message : e)); console.error('file.text() error', e); importFile.value = ''; return; }
    try{
      const sanitize = (s)=>{ s = s.replace(/^\uFEFF/, ''); s = s.replace(/\/\/[^\n\r]*/g, '').replace(/\/\*[\s\S]*?\*\//g, ''); s = s.replace(/,\s*(\}|\])/g, '$1'); return s.trim(); };
      let text = typeof textRaw === 'string' ? textRaw : String(textRaw||'');
      let preset; try{ preset = JSON.parse(text.replace(/^\uFEFF/, '')); }catch(parseErr){ try{ const cleaned = sanitize(text); preset = JSON.parse(cleaned); console.warn('JSONをクリーンアップして読み込みました'); }catch(e2){ const head = text.slice(0,200); alert('読み込みに失敗しました: ' + (parseErr && parseErr.message ? parseErr.message : parseErr) + '\n\n先頭抜粋:\n' + head); console.error('Import JSON head:', head, parseErr, e2); return; } }
      let name = (preset.name || preset.id || 'imported'); name = String(name ?? 'imported').trim() || 'imported';
      preset.id = name; preset.name = name; preset.updatedAt = Date.now();
      const fixHidden = (h)=>{ const out = {}; try{ const keys = (typeof hiddenMap !== 'undefined' && hiddenMap) ? Object.keys(hiddenMap) : (h ? Object.keys(h) : []); keys.forEach(k=>{ const v = h && h[k]; out[k] = Array.isArray(v) ? v : (v instanceof Set) ? Array.from(v) : (v && typeof v === 'object') ? Object.values(v).flat() : []; }); }catch(e){} return out; };
      if (preset.hidden) preset.hidden = fixHidden(preset.hidden);
      if (typeof savePresetToLocal === 'function') savePresetToLocal(preset);
      if (typeof applyPreset === 'function') applyPreset(preset);
    }finally{ importFile.value = ''; }
  });

  /* ===== 入力変更時の挙動（下段はリセットしない） ===== */
  function drawAll(){ syncDPR(); drawMain(); drawPositions(); }

// キー変更 → メインだけ再描画（状態は維持）
['input','change'].forEach(evt => {
  keySel.addEventListener(evt, () => { drawMain(); });
});

// スケール変更 → メインを「全表示」相当でリセットしてから再描画
['input','change'].forEach(evt => {
  scaleSel.addEventListener(evt, () => {
    hiddenMap.main.clear();    // 全表示＝非表示マスクを空に
    showMap.main?.clear();     // 強制表示もリセット
    drawMain();
  });
});
  // フレット数／ラベル表示 → 全体を再描画（非表示マスクは維持）
  ['input','change'].forEach(evt => {
    [fretSel, labelModeSel].forEach(el => {
      el.addEventListener(evt, () => { drawAll(); });
    });
  });

  window.addEventListener('resize', () => drawAll());


   /* 初期表示 */
   (function init(){
     applyDefaultTitles();


     // ▼ 下段8ボードを「初期状態＝全ポジション非表示」にセット（メインは対象外）
     POSITION_IDS.forEach(id => hideAllPositionsForBoard(id));

     drawAll();
     loadPresetList();
     bindAllDragErase();
     setDragEraseUI();
   })();




(() => {
  // A4縦・余白5mmに1ページでフィット
  const PAGE_MM = { w: 210, h: 297, margin: 5 };

  function getPresetTitle() {
    const el = document.getElementById('presetName');
    const name = (el && el.value || '').trim();
    return name || '未保存のプリセット';
  }
  function getMetaLine() {
    const keySel = document.getElementById('keySelect');
    const scaleSel = document.getElementById('scaleSelect');
    return `${keySel?.value || ''} / ${scaleSel?.value || ''}`;
  }  

 // 画面の「上段指板＋7ポジション」を縦一列で合成（PDF用ライト配色で再描画／各ポジションに小見出し）
function composeExportCanvas() {

// ▼ 下段8ボードのみ（上段メインは含めない）※欠けていた pos-4-M も含める
  const ids = ["pos-6-I","pos-6-M","pos-6-P","pos-5-I","pos-5-M","pos-5-P","pos-4-I","pos-4-M"];
  const list = ids.map(id => document.getElementById(id)).filter(Boolean);

// 出力キャンバスの横幅（品質重視）
  const outW = 3000;
  const POS_RATIO  = 0.18;                         // 各ポジションの高さ = outW * 0.18
  const scaledHeights = list.map(() => Math.round(outW * POS_RATIO));

  // タイトル領域（コンパクト）
  const gap = Math.round(outW * 0.0025);
  const titleFontPx = Math.round(outW * 0.022);
  const metaFontPx  = Math.round(outW * 0.012);
  const titlePad    = Math.round(outW * 0.016);
  const titleAreaH  = titlePad + titleFontPx + Math.round(metaFontPx * 1.1) + Math.round(titlePad * 0.4);

  // 各ポジション小見出し（全行に付ける）
  const subFontPx = Math.round(outW * 0.018);
  const subPad    = Math.round(outW * 0.010);
  const labelHeights = list.map(() => (subFontPx + subPad));

  // DOM からポジション名を取得（なければフォールバック）
  const posTitles = ids.map((id, i) => {
    const el = document.querySelector(`.pos-name[data-pos="${id}"]`);
    const txt = (el && el.textContent && el.textContent.trim()) || `タイトル${i+1}`;
    return txt;
  });

  const totalH = titleAreaH
    + scaledHeights.reduce((a,b)=>a+b,0)
    + labelHeights.reduce((a,b)=>a+b,0)
    + gap * (list.length - 1);

  // ▼ PDF用ライト配色（反転）
  const LightStyle = (() => {
    const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
    return {
      board1:'#f2f4f8', board2:'#e8ecf3',
      nut:'#222',
      fret:'#c3c9d6',
      string:'#000000',
      posBorder:'#000000',
      labelInk:'#000000',
      muted:'#000000',
      degRoot:css('--deg-root'),
      degThird:css('--deg-third'),
      degFifth:css('--deg-fifth'),
      degSeventh:css('--deg-seventh'),
      degOther:css('--deg-other'),
      degBlues:css('--deg-blues'),
    };
  })();

// ▼ “ライト配色＋showMap反映＋度数フォールバック”で再描画したスナップショットを作る
  function renderLightSnapshot(targetW, targetH, mapKey){
    const frets = Math.max(12, Math.min(24, parseInt((document.getElementById('fretCount')?.value)||'16')));
    const keySel = document.getElementById('keySelect');
    const scaleSel = document.getElementById('scaleSelect');
    const labelModeSel = document.getElementById('labelMode');
    const root = KEYS.indexOf(keySel?.value || 'C');
    const scaleName = scaleSel?.value || '- Major (Ionian)';
    const labelMode = labelModeSel?.value || 'both';

    const prevDpr = (typeof dpr!=='undefined'? dpr:1);
    if (typeof dpr!=='undefined') dpr = 1; // エクスポートは DPR=1 固定

    const off = document.createElement('canvas');
    off.width = targetW; off.height = targetH;
    const ctx = off.getContext('2d');
    ctx.setTransform(1,0,0,1,0,0);

// 盤面をライト配色で描画
    const g = layoutOn(ctx, off, STRINGS, frets, LightStyle);

// ===== 既存のフレット番号を白帯で消してから大きく再描き =====
    (() => {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.shadowColor = 'rgba(0,0,0,0)';
      ctx.lineWidth = 0;
      ctx.strokeStyle = 'rgba(0,0,0,0)';
      ctx.fillStyle = '#ffffff'; // 閭梧勹逋ｽ
      const fretW   = g.fbW / frets;
      const extraL  = Math.round(fretW * 0.6);
      const wipeH   = Math.round(g.fbH * 0.03);
      const wipeY   = g.fbY + g.fbH + Math.round(g.fbH * 0.01);
      const over    = 2;
      ctx.fillRect(g.baseX - extraL - over, wipeY - over, g.fbW + extraL + over*2, wipeH + over*2);
      ctx.restore();

      const FRET_FONT_SCALE = 0.6;
      const fontPx = Math.round(g.fbH * 0.10 * FRET_FONT_SCALE);
      ctx.font = `700 ${fontPx}px system-ui`;
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const y = g.fbY + g.fbH + Math.round(fontPx * 0.10);
      for (let f = 0; f <= frets; f++) {
        const cx = (f === 0) ? g.baseX - fretW / 2 : g.baseX + fretW * (f - 0.5);
        ctx.fillText(String(f), cx, y);
      }
    })();

// スケール計算
    const {intervals, degrees} = SCALES[scaleName];
    const pcs = new Set(intervals.map(i => (root + i) % 12));
    const degreeMap = new Map(); intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));
    const NOTE_RADIUS_SCALE = 1.8;
    const r = getNoteRadius() * NOTE_RADIUS_SCALE;

// 強制表示（showMap）を反映して可視判定
    for(let s=0; s<STRINGS; s++){
      const openPc = N_SHARP.indexOf(TUNING[s]);
      const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;

// 0フレット（開放）
      const pc0 = openPc % 12;
      const k0 = `${s}:0`;
      const interval0 = (pc0 - root + 12) % 12;
      const forced0 = (showMap[mapKey] && showMap[mapKey].has(k0));
      if (forced0 || (!hiddenMap[mapKey].has(k0) && pcs.has(pc0) && (!chordTonesOnly || isChordToneInterval(interval0)))){
        drawNote(ctx, g.openCx, cy, r, pc0, root, getDegreeTextFor(pc0, root, scaleName, degreeMap), labelMode, keySel?.value || 'C', LightStyle);
      }

      // 1..frets
      for(let f=1; f<=frets; f++){
        const prevX = g.baseX + g.fbW * ((f-1)/frets);
        const thisX = g.baseX + g.fbW * (f/frets);
        const cx = (prevX + thisX)/2;
        const pc = (openPc + f) % 12;
        const k = `${s}:${f}`;
        const interval = (pc - root + 12) % 12;
        const forced = (showMap[mapKey] && showMap[mapKey].has(k));
        if (forced || (!hiddenMap[mapKey].has(k) && pcs.has(pc) && (!chordTonesOnly || isChordToneInterval(interval)))){
          drawNote(ctx, cx, cy, r, pc, root, getDegreeTextFor(pc, root, scaleName, degreeMap), labelMode, keySel?.value || 'C', LightStyle);
        }
      }
    }

    if (typeof dpr!=='undefined') dpr = prevDpr;
    return off;
  }

// 合成キャンバス生成
  const off = document.createElement('canvas');
  off.width = outW;
  off.height = totalH;
  const ctx = off.getContext('2d');
  ctx.clearRect(0, 0, off.width, off.height);

// 背景を白で塗る（透明防止）
  ctx.save(); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, off.width, off.height); ctx.restore();

// タイトルとメタ行
  ctx.fillStyle = '#000000';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = `700 ${titleFontPx}px system-ui`;
  ctx.fillText(getPresetTitle(), titlePad, titlePad);
  ctx.font = `500 ${metaFontPx}px system-ui`;
  ctx.fillStyle = '#333333';

// 各ボード（全8枚）を貼り付け（それぞれに小見出し）
  let yPos = titleAreaH;
  list.forEach((src, i) => {
// 小見出し
    ctx.font = `600 ${subFontPx}px system-ui`;
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(posTitles[i] || `ポジション${i+1}`, Math.round(outW * 0.01), yPos);
    yPos += (subFontPx + subPad);

    const mapKey = ids[i]; // 下段ボードID
    const lightCanvas = renderLightSnapshot(outW, scaledHeights[i], mapKey);
    ctx.drawImage(lightCanvas, 0, yPos);
    yPos += scaledHeights[i];
    if (i < list.length - 1) yPos += gap;
  });

  return off;
}function exportPDF() {
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) { alert('PDFライブラリ（jsPDF）が読み込めていません'); return; }

    const composed = composeExportCanvas();

    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    const m = PAGE_MM.margin;
    const contentW = PAGE_MM.w - m * 2;
    const contentH = PAGE_MM.h - m * 2;

    const imgWmm = contentW;
    const imgHmm = (contentW * composed.height) / composed.width;
    // 高さが足りなければ等比で縮小 → 1ページに収める
    const scale = Math.min(1, contentH / imgHmm);
    const drawW = imgWmm * scale;
    const drawH = imgHmm * scale;
    const x = m + (contentW - drawW) / 2;
    const y = m + (contentH - drawH) / 2;

    const dataURL = composed.toDataURL('image/png');
    doc.addImage(dataURL, 'PNG', x, y, drawW, drawH, undefined, 'FAST');

    const name = getPresetTitle().replace(/[\\/:*?"<>|]/g, '_') || 'export';
    doc.save(`${name}.pdf`);
  }

  // 既存ボタンにだけハンドラを追加（DOM/CSSは一切変更しない）
  const btn = document.getElementById('btnExportPdf');
  if (btn) btn.addEventListener('click', exportPDF);
})();
</script>


</body>
</html>
