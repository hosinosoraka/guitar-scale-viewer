<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Scale Viewer Ver 1.10</title>
  <script src="./jspdf.umd.min.js"></script>
  <style>
    :root{
      /* Dark (default) palette */
      --bg:#0f1115; --panel:#171a21; --ink:#e6e6e6; --muted:#9aa4b2; --accent:#4f8cff;
      --board1:#1b222d; --board2:#121821; --nut:#e2e8f0; --fret:#293042; --string:#d1d7e1;
      --pos-border:#ffffff;  /* ダーク時のポジション縁：白 */
      --label-ink:#000000;   /* 円内の文字色 */
      --deg-root:#3b82f6; --deg-third:#22c55e; --deg-fifth:#ef4444; --deg-seventh:#ec4899; --deg-other:#32d296; --deg-blues:#ffd166;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height:1.5; display:flex; flex-direction:column; min-height:100vh;
    }
    header{
      padding:12px 16px; border-bottom:1px solid #232735;
      background:linear-gradient(180deg, rgba(21,24,35,.85), rgba(20,23,32,.85));
    }
    .toolbar{
      display:grid; gap:10px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      align-items:end; max-width:90vw; margin:0 auto;
    }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type="text"], select, button{
      width:100%; padding:10px 12px; border-radius:12px;
      border:1px solid #2a2f40; background:var(--panel); color:var(--ink); outline:none;
    }
    select:focus, button:focus, input[type="text"]:focus { border-color: var(--accent); }

    main{ padding:16px; display:grid; place-items:center; }
    .card{
      width:100%; max-width:90vw; background:var(--panel);
      border:1px solid #232735; border-radius:12px; padding:12px; margin-bottom:12px;
    }

    canvas{ width:100%; height:360px; display:block; border-radius:12px; background:transparent; }

    .legend{ display:flex; gap:8px; flex-wrap:wrap; font-size:12px; color:var(--muted); padding-top:8px; }
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid #2a2f40; background:var(--panel); }
    .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    .foot { color:var(--muted); text-align:center; font-size:12px; margin-top:8px; }

    .positions{ width:100%; max-width:90vw; margin:0 auto; display:flex; flex-direction:column; gap:12px; }
    .pos-card{ background:var(--panel); border:1px solid #232735; border-radius:12px; padding:12px; }
    .pos-title{ font-size:12px; color:var(--muted); margin:4px 0 8px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .pos-name{ color:var(--ink); font-weight:600; outline: none; padding: 2px 6px; border-radius: 8px; }
    .pos-name:focus{ box-shadow: 0 0 0 2px rgba(79,140,255,0.35); background: rgba(79,140,255,0.08); }
    .pos-canvas{ width:100%; height:360px; display:block; border-radius:12px; }
    .pos-actions{ display:flex; gap:8px; }
    .icon-btn{ border:1px solid #2a2f40; background:transparent; color:var(--ink); padding:6px 10px; border-radius:10px; cursor:pointer; }
    .icon-btn:hover{ border-color:var(--accent); }

    details.dropdown{ border:1px solid #2a2f40; border-radius:12px; background:var(--panel); overflow:hidden; }
    details.dropdown > summary{ list-style:none; cursor:pointer; padding:10px 12px; border-radius:12px; outline:none; user-select:none; }
    details.dropdown[open] > summary{ border-bottom:1px solid #2a2f40; border-bottom-left-radius:0; border-bottom-right-radius:0; }
    details.dropdown .menu{ max-height:320px; overflow:auto; padding:4px 0; }
    .preset-item{ display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border-bottom:1px solid #232735; cursor:pointer; }
    .preset-item:last-child{ border-bottom:none; }
    .preset-item:hover{ background: rgba(255,255,255,0.04); }
    .preset-meta{ flex:1; min-width:0; }
    .preset-name{ font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .preset-sub{ font-size:11px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .row-actions{ display:flex; gap:8px; }
    .empty{ color:var(--muted); padding:12px; font-size:13px; }
    .notice{ color:#9aa4b2; font-size:12px; margin-top:8px; }

/* === 横長で小さい +1 / -1 ボタン用 === */
#btnToggleChordTones { width:auto; }
#btnPosShiftDown,
#btnPosShiftUp,
#btnToggleChordTones {
  width: auto;          /* ← 横幅を自動に戻す！ここが重要 */
  padding: 4px 14px;    /* 横は広め、縦は狭め */

}

#btnToggleDragErase {
  width: auto;
  padding: 4px 14px;
}

  </style>
</head>
<body>
<header>
  <div class="toolbar">
    <div>
      <label for="keySelect">キー</label>
      <select id="keySelect"></select>
    </div>
    <div>
      <label for="scaleSelect">スケール</label>
      <select id="scaleSelect"></select>
    </div>
    <div>
      <label for="labelMode">ラベル表示</label>
      <select id="labelMode">
        <option value="note">音名</option>
        <option value="degree">度数</option>
        <option value="both" selected>両方</option>
      </select>
    </div>
    <div>
      <label for="fretCount">フレット数（12〜24）</label>
      <select id="fretCount"></select>
    </div>
        <div>
      <label>&nbsp;</label>
      <button id="btnExportPdf">PDFで保存</button>
    </div>
<div>
      <label>&nbsp;</label>
      <button id="resetHiddenMain">上段の非表示リセット</button>
    </div>
  </div>
</header>

<main>
<!-- 上段：全体指板 -->
<div class="card">
  <canvas id="fretboard" width="1400" height="520"></canvas>
  <div class="legend" id="legend"></div>
  <div class="foot">
    クリックでポジションの非表示/再表示（上段/下段ともに）
    <br>Ver 1.08　PDF出力の追加、及びバグフィックス
    <br>Ver 1.09　ポジションのシフトボタンを追加、コードトーン表示のボタン追加
    <br>Ver 1.10　ドラッグ消しゴムのボタンを追加
  </div>
  <div style="text-align:center; margin-top:6px;">
    <a href="https://github.com/hosinosoraka/guitar-scale-viewer/blob/main/README.md"
       target="_blank" rel="noopener"
       style="color:yellow; font-weight:bold; text-decoration:none;">
       ReadMe
    </a>
  </div>
</div>

  <!-- プリセット保存/読み込み -->
  <div class="card">
    <div class="toolbar" style="grid-template-columns: 1fr 1fr; padding:0; max-width:unset;">
      <div>
        <label for="presetName">プリセット名</label>
        <input id="presetName" type="text" list="presetNames" placeholder="例）Cメジャー_7ポジ_v1" />
        <datalist id="presetNames"></datalist>
        <div class="notice">同名で保存すると上書きします（キー/スケール/フレット/ラベル表示/各キャンバスの非表示/ポジション名を保存）。</div>
      </div>
      <div>
        <label>&nbsp;</label>
        <div style="display:flex; gap:8px;">
          <button id="btnSavePreset">この状態を保存</button>
          <button id="btnExportPreset">JSONを書き出し</button>
          <button id="btnImportPreset">JSONを読み込み</button>
          <input id="importFile" type="file" accept=".json,application/json" style="display:none;">
        </div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <details id="presetDropdown" class="dropdown">
        <summary>ローカル保存済みプリセット ▾</summary>
        <div id="presetList" class="menu"><div class="empty">（保存されたプリセットはありません）</div></div>
      </details>
    </div>

    <div class="notice" id="presetMeta"></div>
  </div>
  <!-- 7ポジ 横シフトバー（キーも追従して更新） -->
  <div class="card" id="posShiftBar" style="display:flex;justify-content:center;align-items:center;gap:12px;">
    <button id="btnPosShiftDown">-1</button>
    <button id="btnPosShiftUp">+1</button>
    <div style="font-size:12px;color:var(--muted);">7ポジションを横にシフト（キーも±1）</div>
    <button id="btnToggleChordTones">コードトーンのみ表示</button>
    <button id="btnToggleDragErase" title="マウス/タッチでなぞって非表示（ショートカット: E）">ドラッグ消しゴム：OFF</button>

  </div>



  <!-- 下段：7ポジション（名前は編集可） -->
  <section class="positions" id="positions">
    <div class="pos-card">
      <div class="pos-title">
        <span class="pos-name" contenteditable="true" data-pos="pos-6-I" spellcheck="false" title="クリックして名前を編集"></span>
        <div class="pos-actions"><button data-pos="pos-6-I" class="icon-btn btnClear">非表示リセット</button></div>
      </div>
      <canvas class="pos-canvas" id="pos-6-I"></canvas>
    </div>
    <div class="pos-card"><div class="pos-title"><span class="pos-name" contenteditable="true" data-pos="pos-6-M" spellcheck="false" title="クリックして名前を編集"></span><div class="pos-actions"><button data-pos="pos-6-M" class="icon-btn btnClear">非表示リセット</button></div></div><canvas class="pos-canvas" id="pos-6-M"></canvas></div>
    <div class="pos-card"><div class="pos-title"><span class="pos-name" contenteditable="true" data-pos="pos-6-P" spellcheck="false" title="クリックして名前を編集"></span><div class="pos-actions"><button data-pos="pos-6-P" class="icon-btn btnClear">非表示リセット</button></div></div><canvas class="pos-canvas" id="pos-6-P"></canvas></div>
    <div class="pos-card"><div class="pos-title"><span class="pos-name" contenteditable="true" data-pos="pos-5-I" spellcheck="false" title="クリックして名前を編集"></span><div class="pos-actions"><button data-pos="pos-5-I" class="icon-btn btnClear">非表示リセット</button></div></div><canvas class="pos-canvas" id="pos-5-I"></canvas></div>
    <div class="pos-card"><div class="pos-title"><span class="pos-name" contenteditable="true" data-pos="pos-5-M" spellcheck="false" title="クリックして名前を編集"></span><div class="pos-actions"><button data-pos="pos-5-M" class="icon-btn btnClear">非表示リセット</button></div></div><canvas class="pos-canvas" id="pos-5-M"></canvas></div>
    <div class="pos-card"><div class="pos-title"><span class="pos-name" contenteditable="true" data-pos="pos-5-P" spellcheck="false" title="クリックして名前を編集"></span><div class="pos-actions"><button data-pos="pos-5-P" class="icon-btn btnClear">非表示リセット</button></div></div><canvas class="pos-canvas" id="pos-5-P"></canvas></div>
    <div class="pos-card"><div class="pos-title"><span class="pos-name" contenteditable="true" data-pos="pos-4-I" spellcheck="false" title="クリックして名前を編集"></span><div class="pos-actions"><button data-pos="pos-4-I" class="icon-btn btnClear">非表示リセット</button></div></div><canvas class="pos-canvas" id="pos-4-I"></canvas></div>
  </section>
</main>

<script>
  /* ===== 基本設定 ===== */
  const STRINGS = 6;
  const NOTE_RADIUS = 18;  // PC
  const INLAY_R = 5.5, INLAY_R_12 = 6.5;
  const LABEL_OFFSET_FACTOR = 0.42;
  function getNoteRadius(){ return (window.innerWidth <= 768) ? NOTE_RADIUS * 0.7 : NOTE_RADIUS; }
  let dpr = 1; function syncDPR(){ dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1)); }

  /* デフォルトのポジション名 */
  const POSITION_IDS = ['pos-6-I','pos-6-M','pos-6-P','pos-5-I','pos-5-M','pos-5-P','pos-4-I'];
  const DEFAULT_TITLES = {
    'pos-6-I':'タイトル１　（例　6弦スタート｜人差し指）等',
    'pos-6-M':'タイトル２',
    'pos-6-P':'タイトル３',
    'pos-5-I':'タイトル４',
    'pos-5-M':'タイトル５',
    'pos-5-P':'タイトル６',
    'pos-4-I':'タイトル７',
  };

  /* 音名・スケール */
  const N_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const N_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
  const KEYS    = [...N_SHARP];
  const SCALES = {
    "- Major (Ionian)": { intervals:[0,2,4,5,7,9,11], degrees:["1","9th","3","11th","5","13th","7"] },
    "Dorian": { intervals:[0,2,3,5,7,9,10], degrees:["1","9th","m3","11th","5","13th","m7"] },
    "Phrygian": { intervals:[0,1,3,5,7,8,10], degrees:["1","b9th","m3","11th","5","m6","m7"] },
    "Lydian": { intervals:[0,2,4,6,7,9,11], degrees:["1","9th","3","#4","5","13th","7"] },
    "Mixolydian": { intervals:[0,2,4,5,7,9,10], degrees:["1","9th","3","11th","5","13th","m7"] },
    "Natural Minor (Aeolian)":  { intervals:[0,2,3,5,7,8,10], degrees:["1","9th","m3","11th","5","m6","m7"] },
    "Locrian": { intervals:[0,1,3,5,6,8,10], degrees:["1","b9th","m3","11th","b5","m6","m7"] },
    "- Melodic Minor": { intervals:[0,2,3,5,7,9,11], degrees:["1","9th","m3","11th","5","13th","7"] },
    "Dorian b2": { intervals:[0,1,3,5,7,9,10], degrees:["1","b9th","m3","11th","5","13th","m7"] },
    "Lydian #5": { intervals:[0,2,4,6,8,9,11], degrees:["1","9th","3","#4","#5","13th","7"] },
    "Lydian b7": { intervals:[0,2,4,6,7,9,10], degrees:["1","9th","3","#4","5","13th","m7"] },
    "Mixolydian b6": { intervals:[0,2,4,5,7,8,10], degrees:["1","9th","3","11th","5","m6","m7"] },
    "Locrian #2": { intervals:[0,2,3,5,6,8,10], degrees:["1","9th","m3","11th","b5","m6","m7"] },
    "Altered (Super Locrian)": { intervals:[0,1,3,4,6,8,10], degrees:["1","b9th","#9th","3","b5","#11","b13","m7"] },
    "- Harmonic Minor": { intervals:[0,2,3,5,7,8,11], degrees:["1","9th","m3","11th","5","m6","7"] },
    "Locrian #6": { intervals:[0,1,3,5,6,9,10], degrees:["1","b9th","m3","11th","b5","13th","m7"] },
    "Ionian #5": { intervals:[0,2,4,5,8,9,11], degrees:["1","9th","3","11th","#5","13th","7"] },
    "Dorian #4 (Ukrainian)": { intervals:[0,2,3,6,7,9,10], degrees:["1","9th","m3","#4","5","13th","m7"] },
    "Phrygian Dominant (Mixolydian b9 b13)": { intervals:[0,1,4,5,7,8,10], degrees:["1","b9th","3","11th","5","m6","m7"] },
    "Lydian #2": { intervals:[0,3,4,6,7,9,11], degrees:["1","#2","3","#4","5","13th","7"] },
    "Ultralocrian (Super Locrian bb7)": { intervals:[0,1,3,4,6,8,9], degrees:["1","b9th","m3","3","b5","m6","bb7"] },
    "- Half–Whole Diminished": { intervals: [0,1,3,4,6,7,9,10], degrees:["1","b9th","m3","3","b5","5","13th","m7"]},
    "Whole–Half Diminished": { intervals: [0,2,3,5,6,8,9,11], degrees:["1","9th","m3","11th","b5","m6","13th","7"]},
    "Major Pentatonic": { intervals:[0,2,4,7,9], degrees:["1","9th","3","5","13th"] },
    "Minor Pentatonic": { intervals:[0,3,5,7,10], degrees:["1","m3","11th","5","m7"] },
    "Blues": { intervals:[0,3,5,6,7,10], degrees:["1","m3","11th","b5","5","m7"] },

  };
  const TUNING = ["E","B","G","D","A","E"]; // 1弦→6弦

  /* ===== DOM ===== */
  const keySel = document.getElementById('keySelect');
  const scaleSel = document.getElementById('scaleSelect');
  const labelModeSel = document.getElementById('labelMode');
  const fretSel = document.getElementById('fretCount');
  const resetHiddenMain = document.getElementById('resetHiddenMain');
  const mainCanvas = document.getElementById('fretboard');
  const mainCtx = mainCanvas.getContext('2d');

  const presetNameInput = document.getElementById('presetName');
  const presetNamesDatalist = document.getElementById('presetNames');
  const presetDropdown = document.getElementById('presetDropdown');
  const presetList = document.getElementById('presetList');
  const presetMeta = document.getElementById('presetMeta');
  const btnSavePreset = document.getElementById('btnSavePreset');
  const btnExportPreset = document.getElementById('btnExportPreset');
  const btnImportPreset = document.getElementById('btnImportPreset');
  const importFile = document.getElementById('importFile');
  // ▼ 7ポジ 横シフト：hiddenMap の座標を ±1 ずらし、キーも ±1 変更
  function shiftPositionsMask(delta){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    POSITION_IDS.forEach(id => {
      const src = hiddenMap[id];
      const dst = new Set();
      src.forEach(key => {
        const m = /^(\d+):(\d+)$/.exec(key);
        if(!m) return;
        const s = parseInt(m[1], 10);
        const f = parseInt(m[2], 10) + delta;
        if (f < 0 || f > frets) return; // 範囲外は捨てる
        dst.add(`${s}:${f}`);
      });
      hiddenMap[id] = dst;
    });
  }
  function stepKey(delta){
    const keys = KEYS;
    let idx = keys.indexOf(keySel.value);
    if (idx < 0) idx = 0;
    keySel.value = keys[(idx + delta + 12) % 12];
  }
  function onPosShift(delta){
    shiftPositionsMask(delta); // シェイプを物理的に1フレット移動
    stepKey(delta);            // UIのキーも ±1 進める
    drawAll();                 // リセットはしない（隠し状態維持）
  }
  document.getElementById('btnPosShiftUp')?.addEventListener('click', ()=> onPosShift(+1));
  document.getElementById('btnPosShiftDown')?.addEventListener('click', ()=> onPosShift(-1));

// コードトーントグル
const btnToggleChord = document.getElementById('btnToggleChordTones');
btnToggleChord?.addEventListener('click', () => {
  chordTonesOnly = !chordTonesOnly;
  btnToggleChord.textContent = chordTonesOnly ? 'コードトーン再表示' : 'コードトーンのみ表示';
  drawAll();
});


  // 下段ポジション名の要素
  const posNameEls = {};
  document.querySelectorAll('.pos-name').forEach(el => { posNameEls[el.dataset.pos] = el; });

  // セレクト初期化
  KEYS.forEach(k=>{ const o=document.createElement('option'); o.value=o.textContent=k; keySel.appendChild(o); });
  Object.keys(SCALES).forEach(n=>{ const o=document.createElement('option'); o.value=o.textContent=n; scaleSel.appendChild(o); });
  for (let f=12; f<=24; f++){ const o=document.createElement('option'); o.value=String(f); o.textContent=String(f); fretSel.appendChild(o); }
  keySel.value='C'; scaleSel.value='- Major (Ionian)'; fretSel.value='24';

  // デフォルト名を反映
  function applyDefaultTitles(){
    Object.entries(DEFAULT_TITLES).forEach(([id, name])=>{
      if (posNameEls[id]) posNameEls[id].textContent = name;
    });
  }

  // 非表示セット
  const hiddenMap = { main:new Set() }; POSITION_IDS.forEach(id=> hiddenMap[id]=new Set());

  /* === コードトーン表示トグル === */
let chordTonesOnly = false;
function isChordToneInterval(interval){
  return interval === 0 || interval === 3 || interval === 4 || interval === 7 || interval === 10 || interval === 11;
}

/* ===== 共通描画ユーティリティ ===== */
  const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  function styleSnapshot(){
    return {
      board1: css('--board1'), board2: css('--board2'),
      nut: css('--nut'), fret: css('--fret'), string: css('--string'),
      posBorder: css('--pos-border'), labelInk: css('--label-ink'),
      muted: css('--muted'),
      degRoot: css('--deg-root'), degThird: css('--deg-third'),
      degFifth: css('--deg-fifth'), degSeventh: css('--deg-seventh'),
      degOther: css('--deg-other'), degBlues: css('--deg-blues')
    };
  }
  function roundRect(ctx, x, y, w, h, r){
    if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
  }
  function degreeColor(i, S){
    if (i===0) return S.degRoot;
    if (i===3||i===4) return S.degThird;
    if (i===7) return S.degFifth;
    if (i===10||i===11) return S.degSeventh;
    if (i===6) return S.degBlues;
    return S.degOther;
  }
  function drawNote(ctx, cx, cy, r, pc, root, degreeText, mode, keyName, S){
    const interval = (pc - root + 12) % 12;
    const fill = degreeColor(interval, S);
    const flats = ['F','Bb','Eb','Ab','Db','Gb','Cb'].includes(keyName);
    const noteName = (flats?N_FLAT:N_SHARP)[pc];

    ctx.fillStyle = fill;
    ctx.strokeStyle = S.posBorder;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    ctx.fillStyle = S.labelInk;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

    if (mode === 'note'){
      ctx.font = `bold ${Math.round(r*0.75)}px system-ui`;
      ctx.fillText(noteName, cx, cy);
    } else if (mode === 'degree'){
      ctx.font = `bold ${Math.round(r*0.75)}px system-ui`;
      ctx.fillText(degreeText || '', cx, cy);
    } else {
      const dy = r * LABEL_OFFSET_FACTOR;
      ctx.font = `bold ${Math.round(r*0.68)}px system-ui`;
      ctx.fillText(degreeText || '', cx, cy - dy);
      ctx.font = `bold ${Math.round(r*0.68)}px system-ui`;
      ctx.fillText(noteName,       cx, cy + dy);
    }
  }
  function layoutOn(ctx, canvasEl, strings, frets, S){
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    ctx.clearRect(0,0,w,h);
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;

    const boardX = 20, boardW = w - 40;
    const R = 16;
    const grd = ctx.createLinearGradient(0, fbY, 0, fbY + fbH);
    grd.addColorStop(0, S.board1); grd.addColorStop(1, S.board2);
    ctx.fillStyle = grd;
    roundRect(ctx, boardX, fbY, boardW, fbH, R); ctx.fill();
    ctx.strokeStyle = '#1f2432'; ctx.lineWidth = 1; ctx.stroke();

    ctx.fillStyle = S.nut; ctx.fillRect(baseX - 10, fbY, 10, fbH);

    ctx.strokeStyle = S.fret; ctx.lineWidth = 2;
    for(let f=1; f<=frets; f++){
      const x = baseX + fbW * (f / frets);
      ctx.beginPath(); ctx.moveTo(x, fbY); ctx.lineTo(x, fbY + fbH); ctx.stroke();
    }

    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    ctx.fillStyle = S.muted; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
    const footY = fbY + fbH + 16; ctx.fillText('0', openCx, footY);
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      ctx.fillText(String(f), (prevX + thisX)/2, footY);
    }

    ctx.fillStyle = '#3b80ff66';
    [3,5,7,9,12,15,17,19,21,24].forEach(f=>{
      if (f>frets) return;
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      const xCenter = (prevX + thisX) / 2;
      if (f%12===0){
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.33, INLAY_R_12, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.66, INLAY_R_12, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(xCenter, fbY+fbH*0.5, INLAY_R, 0, Math.PI*2); ctx.fill();
      }
    });

    for(let s=0; s<strings; s++){
      const y = fbY + fbH * (s+0.5)/strings;
      ctx.strokeStyle = S.string; ctx.lineWidth = 1 + (strings - s)*0.4;
      ctx.beginPath(); ctx.moveTo(baseX, y); ctx.lineTo(baseX + fbW, y); ctx.stroke();
    }

    return {fbY, fbH, baseX, fbW, openCx};
  }
  function buildScale(root, name){
    const {intervals, degrees} = SCALES[name];
    const pcs = new Set(intervals.map(i => (root + i) % 12));
    const degreeMap = new Map(); intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));
    return {pcs, degreeMap};
  }

  /* ===== 上段描画 ===== */
  function drawMain(){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const root = KEYS.indexOf(keySel.value);
    const scaleName = scaleSel.value;
    const labelMode = labelModeSel.value;

    const cssW = mainCanvas.clientWidth|0, cssH = mainCanvas.clientHeight|0;
    mainCanvas.width = Math.floor(cssW * dpr); mainCanvas.height = Math.floor(cssH * dpr);
    mainCtx.setTransform(dpr,0,0,dpr,0,0);

    const S = styleSnapshot();
    const g = layoutOn(mainCtx, mainCanvas, STRINGS, frets, S);
    const {pcs, degreeMap} = buildScale(root, scaleName);
    const r = getNoteRadius();

    for(let s=0; s<STRINGS; s++){
      const openPc = N_SHARP.indexOf(TUNING[s]);
      const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;

      const pc0 = openPc % 12;
      const k0 = `${s}:0`;
      const interval0 = (pc0 - root + 12) % 12;
        if (!hiddenMap.main.has(k0) && pcs.has(pc0) && (!chordTonesOnly || isChordToneInterval(interval0))){
        drawNote(mainCtx, g.openCx, cy, r, pc0, root, degreeMap.get(pc0), labelMode, keySel.value, S);
      }
      for(let f=1; f<=frets; f++){
        const prevX = g.baseX + g.fbW * ((f-1)/frets);
        const thisX = g.baseX + g.fbW * (f/frets);
        const cx = (prevX + thisX)/2;
        const pc = (openPc + f) % 12;
        const k = `${s}:${f}`;
        const interval = (pc - root + 12) % 12;
                if (!hiddenMap.main.has(k) && pcs.has(pc) && (!chordTonesOnly || isChordToneInterval(interval))){
          drawNote(mainCtx, cx, cy, r, pc, root, degreeMap.get(pc), labelMode, keySel.value, S);
        }
      }
    }

    const legend = document.getElementById('legend');
    legend.innerHTML = `
      <span class="chip"><span class="dot" style="background:var(--deg-root)"></span>ルート(1)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-third)"></span>3度(m3/M3)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-fifth)"></span>5度</span>
      <span class="chip"><span class="dot" style="background:var(--deg-seventh)"></span>7度(m7/M7)</span>
      <span class="chip"><span class="dot" style="background:var(--deg-other)"></span>その他スケール音</span>
      <span class="chip"><span class="dot" style="background:var(--deg-blues)"></span>ブルーノート</span>
      <span>キー: <b>${keySel.value}</b></span>
      <span>スケール: <b>${scaleSel.value}</b></span>
      <span>ラベル: <b>${labelModeSel.options[labelModeSel.selectedIndex].textContent}</b></span>
    `;
  }
  mainCanvas.addEventListener('click', (ev)=>{
    const rect = mainCanvas.getBoundingClientRect();
    toggleHiddenAtPoint('main', mainCanvas, ev.clientX - rect.left, ev.clientY - rect.top, drawMain);
  });
  resetHiddenMain.addEventListener('click', ()=>{ hiddenMap.main.clear(); drawMain(); });

  /* ===== 下段：7枚描画 ===== */
  function drawOnePos(canvasId){
    const el = document.getElementById(canvasId);
    const ctx = el.getContext('2d', { alpha:true });
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const root = KEYS.indexOf(keySel.value);
    const scaleName = scaleSel.value;
    const labelMode = labelModeSel.value;

    const cssW = el.clientWidth|0, cssH = el.clientHeight|0;
    el.width = Math.floor(cssW * dpr); el.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const S = styleSnapshot();
    const g = layoutOn(ctx, el, STRINGS, frets, S);
    const {pcs, degreeMap} = buildScale(root, scaleName);
    const r = getNoteRadius();

    for(let s=0; s<STRINGS; s++){
      const openPc = N_SHARP.indexOf(TUNING[s]);
      const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;

      const pc0 = openPc % 12;
      const k0 = `${s}:0`;
      const interval0 = (pc0 - root + 12) % 12;
    if (!hiddenMap[canvasId].has(k0) && pcs.has(pc0) && (!chordTonesOnly || isChordToneInterval(interval0))){
        drawNote(ctx, g.openCx, cy, r, pc0, root, degreeMap.get(pc0), labelMode, keySel.value, S);
      }
      for(let f=1; f<=frets; f++){
        const prevX = g.baseX + g.fbW * ((f-1)/frets);
        const thisX = g.baseX + g.fbW * (f/frets);
        const cxX = (prevX + thisX)/2;
        const pc = (openPc + f) % 12;
        const k = `${s}:${f}`;
        const interval = (pc - root + 12) % 12;
    if (!hiddenMap[canvasId].has(k) && pcs.has(pc) && (!chordTonesOnly || isChordToneInterval(interval))){
          drawNote(ctx, cxX, cy, r, pc, root, degreeMap.get(pc), labelMode, keySel.value, S);
        }
      }
    }
  }
  function drawPositions(){ POSITION_IDS.forEach(id => drawOnePos(id)); }
  POSITION_IDS.forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener('click', (ev)=>{
      const rect = el.getBoundingClientRect();
      toggleHiddenAtPoint(id, el, ev.clientX - rect.left, ev.clientY - rect.top, ()=>drawOnePos(id));
    });
  });
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('.btnClear');
    if (!btn) return;
    const id = btn.getAttribute('data-pos');
    hiddenMap[id].clear();
    drawOnePos(id);
  });

  function toggleHiddenAtPoint(mapKey, canvasEl, x, y, rerender){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;
    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
    let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

    const centers = [openCx];
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      centers.push( (prevX + thisX)/2 );
    }
    let nearestF = 0, best = Infinity;
    centers.forEach((cx, i) => { const d = Math.abs(cx - x); if (d < best){ best = d; nearestF = i; } });

    const key = `${s}:${nearestF}`;
    const set = hiddenMap[mapKey];
    if (set.has(key)) set.delete(key); else set.add(key);

    (rerender || (()=>{ drawMain(); drawPositions(); }))();
  }
  // ==== 追加：ドラッグで非表示にする「消しゴム」機能 ====
  function hideAtPoint(mapKey, canvasEl, x, y){
    const frets = Math.max(12, Math.min(24, parseInt(fretSel.value||'16')));
    const w = canvasEl.width / dpr, h = canvasEl.height / dpr;
    const M = {left: 120, right: 24, top: 36, bottom: 56};
    const fbY = M.top, fbH = h - M.top - M.bottom;
    const baseX = M.left, fbW = w - baseX - M.right;
    const cellW = fbW / frets;
    const openCx = baseX - cellW * 0.5;

    const sFloat = ((y - fbY) / fbH) * STRINGS - 0.5;
    let s = Math.round(sFloat); s = Math.min(STRINGS-1, Math.max(0, s));

    const centers = [openCx];
    for (let f=1; f<=frets; f++){
      const prevX = baseX + fbW * ((f-1)/frets);
      const thisX = baseX + fbW * (f/frets);
      centers.push( (prevX + thisX)/2 );
    }
    let nearestF = 0, best = Infinity;
    centers.forEach((cx, i) => { const d = Math.abs(cx - x); if (d < best){ best = d; nearestF = i; } });
    const key = `${s}:${nearestF}`;
    hiddenMap[mapKey].add(key);
  }

  let dragEraseEnabled = false;
  let isErasing = false;

  function setDragEraseUI(){
    const btn = document.getElementById('btnToggleDragErase');
    if (btn) btn.textContent = 'ドラッグ消しゴム：' + (dragEraseEnabled ? 'ON' : 'OFF');
  }

  function attachDragErase(mapKey, canvasEl, rerender){
    const getXY = (ev) => {
      const rect = canvasEl.getBoundingClientRect();
      return {
        x: (ev.clientX ?? (ev.touches && ev.touches[0]?.clientX) ?? 0) - rect.left,
        y: (ev.clientY ?? (ev.touches[0]?.clientY) ?? 0) - rect.top
      };
    };

    const onDown = (ev) => {
      if (!dragEraseEnabled) return;
      isErasing = true;
      const {x,y} = getXY(ev);
      hideAtPoint(mapKey, canvasEl, x, y);
      (rerender||(()=>{ drawMain(); drawPositions(); }))();
      ev.preventDefault?.();
    };
    const onMove = (ev) => {
      if (!dragEraseEnabled || !isErasing) return;
      const {x,y} = getXY(ev);
      hideAtPoint(mapKey, canvasEl, x, y);
      (rerender||(()=>{ drawMain(); drawPositions(); }))();
      ev.preventDefault?.();
    };
    const onUp = () => { isErasing = false; };

    canvasEl.addEventListener('pointerdown', onDown);
    canvasEl.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    canvasEl.addEventListener('pointerleave', onUp);
    // touch fallback
    canvasEl.addEventListener('touchstart', onDown, {passive:false});
    canvasEl.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);
  }

  // Eキー／ボタンクリックでON/OFF
  document.addEventListener('keydown', (e)=>{
    if (e.key && e.key.toLowerCase() === 'e'){
      dragEraseEnabled = !dragEraseEnabled;
      setDragEraseUI();
    }
  });
  document.getElementById('btnToggleDragErase')?.addEventListener('click', ()=>{
    dragEraseEnabled = !dragEraseEnabled;
    setDragEraseUI();
  });

  function bindAllDragErase(){
    attachDragErase('main', mainCanvas, drawMain);
    POSITION_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) attachDragErase(id, el, ()=>drawOnePos(id));
    });
  }


  /* ===== プリセット（localStorage） ===== */
  const LS_KEY = 'gsv_presets_v1';

  function lsGet(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return [];
      const list = JSON.parse(raw);
      return Array.isArray(list) ? list : [];
    }catch(e){ return []; }
  }
  function lsSet(list){ try{ localStorage.setItem(LS_KEY, JSON.stringify(list)); }catch(e){} }
  function renderPresetNameDatalist(list){
    presetNamesDatalist.innerHTML = '';
    list.forEach(p=>{ const opt = document.createElement('option'); opt.value = p.name; presetNamesDatalist.appendChild(opt); });
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m])); }
  function renderPresetDropdown(list){
    presetList.innerHTML = '';
    if (!list.length){ presetList.innerHTML = `<div class="empty">（保存されたプリセットはありません）</div>`; return; }
    const sorted = [...list].sort((a,b)=> b.updatedAt - a.updatedAt);
    sorted.forEach(p=>{
      const row = document.createElement('div'); row.className = 'preset-item';
      const meta = document.createElement('div'); meta.className = 'preset-meta';
      meta.innerHTML = `<div class="preset-name">${escapeHtml(p.name)}</div>
        <div class="preset-sub">${escapeHtml(p.meta.key)} / ${escapeHtml(p.meta.scale)} / Frets:${p.meta.frets}${p.meta.labelMode?` / ${escapeHtml(p.meta.labelMode)}`:''}</div>`;
      const actions = document.createElement('div'); actions.className = 'row-actions';
      const loadBtn = document.createElement('button'); loadBtn.className='icon-btn'; loadBtn.textContent='読み込む';
      loadBtn.addEventListener('click', (e)=>{ e.stopPropagation(); applyPreset(p); });
      const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.textContent='🗑'; delBtn.title='削除';
      delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if (confirm(`「${p.name}」を削除しますか？`)) deletePresetFromLocal(p.id); });
      actions.appendChild(loadBtn); actions.appendChild(delBtn);
      row.appendChild(meta); row.appendChild(actions);
      row.addEventListener('click', ()=> applyPreset(p));
      presetList.appendChild(row);
    });
  }
  function loadPresetList(){ const list = lsGet(); renderPresetDropdown(list); renderPresetNameDatalist(list); return list; }
  function savePresetToLocal(preset){ const list = lsGet(); const idx = list.findIndex(x => x.id === preset.id); if (idx >= 0) list[idx] = preset; else list.push(preset); lsSet(list); renderPresetDropdown(list); renderPresetNameDatalist(list); presetMeta.textContent = `保存しました: ${preset.name}`; }
  function deletePresetFromLocal(id){ const list = lsGet().filter(x => x.id !== id); lsSet(list); renderPresetDropdown(list); renderPresetNameDatalist(list); presetMeta.textContent = 'プリセットを削除しました'; }

  function currentStateToPreset(name){
  const meta = { key:keySel.value, scale:scaleSel.value, frets:parseInt(fretSel.value||'16'), labelMode:labelModeSel.value };
  const hiddenObj = {}; Object.keys(hiddenMap).forEach(k => hiddenObj[k] = Array.from(hiddenMap[k]));
  // ▼ 7つのポジション名を保存（空白はトリム、空なら現状のテキストをそのまま）
  const posTitles = {};
  POSITION_IDS.forEach(id => {
    const el = posNameEls[id];
    if (!el) return;
    const txt = (el.textContent ?? '').trim();
    posTitles[id] = txt;
  });
  return { id: name, name, meta, hidden: hiddenObj, posTitles, updatedAt: Date.now() };
  }
  function applyPreset(preset){
    keySel.value = preset.meta.key;
    scaleSel.value = preset.meta.scale;
    fretSel.value = String(preset.meta.frets);
    if (preset.meta.labelMode) labelModeSel.value = preset.meta.labelMode;

    Object.keys(hiddenMap).forEach(k=>{
      hiddenMap[k].clear();
      (preset.hidden?.[k] || []).forEach(v=> hiddenMap[k].add(v));
    });

  // ▼ 7つのポジション名を復元（後方互換：posTitles が無ければスキップ）
  if (preset.posTitles && typeof preset.posTitles === 'object') {
    POSITION_IDS.forEach(id => {
      const el = posNameEls[id];
      if (!el) return;
      const val = preset.posTitles[id];
      if (typeof val === 'string' && val.trim().length) {
        el.textContent = val.trim();
      }
    });
  }

    presetNameInput.value = preset.name;
    drawAll();
    presetMeta.textContent = `読み込み: ${preset.name}（キー: ${preset.meta.key} / スケール: ${preset.meta.scale} / フレット: ${preset.meta.frets}）`;
    presetDropdown.open = false;
  }

  // 保存/読込ボタン
  btnSavePreset.addEventListener('click', ()=>{ const name = (presetNameInput.value || '').trim(); if (!name){ alert('プリセット名を入力してください'); presetNameInput.focus(); return; } savePresetToLocal( currentStateToPreset(name) ); });
  presetNameInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); btnSavePreset.click(); } });
  btnExportPreset.addEventListener('click', ()=>{
    const name = (presetNameInput.value || 'preset').replace(/[\\/:*?"<>|]/g,'_');
    const preset = currentStateToPreset(name);
    const blob = new Blob([JSON.stringify(preset,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${name}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    presetMeta.textContent = `JSONを書き出しました: ${name}.json`;
  });
  btnImportPreset.addEventListener('click', ()=> importFile.click());
  importFile.addEventListener('change', async ()=>{
    const file = importFile.files && importFile.files[0]; if (!file) return;
    let textRaw = '';
    try{ textRaw = await file.text(); }catch(e){ alert('ファイルの読み込みに失敗: ' + (e && e.message ? e.message : e)); console.error('file.text() error', e); importFile.value = ''; return; }
    try{
      const sanitize = (s)=>{ s = s.replace(/^\uFEFF/, ''); s = s.replace(/\/\/[^\n\r]*/g, '').replace(/\/\*[\s\S]*?\*\//g, ''); s = s.replace(/,\s*(\}|\])/g, '$1'); return s.trim(); };
      let text = typeof textRaw === 'string' ? textRaw : String(textRaw||'');
      let preset; try{ preset = JSON.parse(text.replace(/^\uFEFF/, '')); }catch(parseErr){ try{ const cleaned = sanitize(text); preset = JSON.parse(cleaned); console.warn('JSONをクリーンアップして読み込みました'); }catch(e2){ const head = text.slice(0,200); alert('読み込みに失敗しました: ' + (parseErr && parseErr.message ? parseErr.message : parseErr) + '\n\n先頭抜粋:\n' + head); console.error('Import JSON head:', head, parseErr, e2); return; } }
      let name = (preset.name || preset.id || 'imported'); name = String(name ?? 'imported').trim() || 'imported';
      preset.id = name; preset.name = name; preset.updatedAt = Date.now();
      const fixHidden = (h)=>{ const out = {}; try{ const keys = (typeof hiddenMap !== 'undefined' && hiddenMap) ? Object.keys(hiddenMap) : (h ? Object.keys(h) : []); keys.forEach(k=>{ const v = h && h[k]; out[k] = Array.isArray(v) ? v : (v instanceof Set) ? Array.from(v) : (v && typeof v === 'object') ? Object.values(v).flat() : []; }); }catch(e){} return out; };
      if (preset.hidden) preset.hidden = fixHidden(preset.hidden);
      if (typeof savePresetToLocal === 'function') savePresetToLocal(preset);
      if (typeof applyPreset === 'function') applyPreset(preset);
    }finally{ importFile.value = ''; }
  });

  /* ===== 入力変更で毎回リセット＆再描画 ===== */
  function resetHiddenAll(){ Object.keys(hiddenMap).forEach(k => hiddenMap[k].clear()); }
  function drawAll(){ syncDPR(); drawMain(); drawPositions(); }
  ['input','change'].forEach(evt =>
    [keySel, scaleSel, fretSel, labelModeSel].forEach(el =>
      el.addEventListener(evt, ()=>{ resetHiddenAll(); drawAll(); })
    )
  );
  window.addEventListener('resize', ()=> drawAll());

   /* 初期表示 */
   (function init(){
     applyDefaultTitles();
     drawAll();
     loadPresetList();
     bindAllDragErase();
     setDragEraseUI();
   })();


(() => {
  // A4縦・余白5mmに1ページでフィット
  const PAGE_MM = { w: 210, h: 297, margin: 5 };

  function getPresetTitle() {
    const el = document.getElementById('presetName');
    const name = (el && el.value || '').trim();
    return name || '未保存のプリセット';
  }
  function getMetaLine() {
    const keySel = document.getElementById('keySelect');
    const scaleSel = document.getElementById('scaleSelect');
    return `${keySel?.value || ''} / ${scaleSel?.value || ''}`;
  }  

 // 画面の「上段指板＋7ポジション」を縦一列で合成（PDF用ライト配色で再描画／各ポジションに小見出し）
function composeExportCanvas() {
  const mainCanvas = document.getElementById('fretboard');
  const ids = ['pos-6-I','pos-6-M','pos-6-P','pos-5-I','pos-5-M','pos-5-P','pos-4-I'];
  const list = [mainCanvas, ...ids.map(id => document.getElementById(id))].filter(Boolean);

  // 画面の見た目比率を優先（clientWidth/Height）。品質向上のため横幅は2倍に。

  const outW = 3000;
 // ウィンドウ非依存：PDF用は “固定の縦横比” を採用（好みで調整可）
 const MAIN_RATIO = 0.22; // 上段・全体指板の高さ = outW * 0.22
 const POS_RATIO  = 0.18; // 各ポジションの高さ = outW * 0.18
 const scaledHeights = list.map((_, i) =>
   Math.round(outW * (i === 0 ? MAIN_RATIO : POS_RATIO))
 );

  // タイトル領域（コンパクト）
  const gap = Math.round(outW * 0.0025);           // 0.25%（必要なら 0 に）
  const titleFontPx = Math.round(outW * 0.022);
  const metaFontPx  = Math.round(outW * 0.012);
  const titlePad    = Math.round(outW * 0.016);
  const titleAreaH  = titlePad + titleFontPx + Math.round(metaFontPx * 1.1) + Math.round(titlePad * 0.4);

  // 各ポジション小見出しの高さ（上段＝index 0 は見出しなし）
  const subFontPx = Math.round(outW * 0.018);
  const subPad    = Math.round(outW * 0.010);
  const labelHeights = list.map((_, i) => i === 0 ? 0 : (subFontPx + subPad));

  // DOMからポジション名を取得（なければフォールバック）
  const posTitles = ids.map((id, i) => {
    const el = document.querySelector(`.pos-name[data-pos="${id}"]`);
    const txt = (el && el.textContent && el.textContent.trim()) || `タイトル${i+1}`;
    return txt;
  });

  const totalH = titleAreaH
    + scaledHeights.reduce((a,b)=>a+b,0)
    + labelHeights.reduce((a,b)=>a+b,0)
    + gap * (list.length - 1);

  // ▼ PDF用ライト配色（要望どおり）
  // - 指板(board1/2)・フレット線はライト（反転系）
  // - 弦は黒、ポジション縁（白丸の輪郭）も黒、フレット番号も黒
  // - 音符の度数色は既存のまま流用
  const LightStyle = (() => {
    const css = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
    return {
      board1:'#f2f4f8', board2:'#e8ecf3',
      nut:'#222',
      fret:'#c3c9d6',
      string:'#000000',
      posBorder:'#000000',
      labelInk:'#000000',
      muted:'#000000',
      degRoot:css('--deg-root'),
      degThird:css('--deg-third'),
      degFifth:css('--deg-fifth'),
      degSeventh:css('--deg-seventh'),
      degOther:css('--deg-other'),
      degBlues:css('--deg-blues'),
    };
  })();

  // ▼ 既存ロジックを使ってライト配色で“再描画”するヘルパ
  function renderLightSnapshot(targetW, targetH, mapKey){
    const frets = Math.max(12, Math.min(24, parseInt((document.getElementById('fretCount')?.value)||'16')));
    const keySel = document.getElementById('keySelect');
    const scaleSel = document.getElementById('scaleSelect');
    const labelModeSel = document.getElementById('labelMode');
    const root = KEYS.indexOf(keySel?.value || 'C');
    const scaleName = scaleSel?.value || '- Major (Ionian)';
    const labelMode = labelModeSel?.value || 'both';

    const prevDpr = (typeof dpr!=='undefined'? dpr:1);
    if (typeof dpr!=='undefined') dpr = 1; // エクスポートはDPR=1固定

    const off = document.createElement('canvas');
    off.width = targetW; off.height = targetH;
    const ctx = off.getContext('2d');
    ctx.setTransform(1,0,0,1,0,0);

    // 板面・フレット・弦などをライト配色で描画
    const g = layoutOn(ctx, off, STRINGS, frets, LightStyle);

// ===== PDF用：既存フレット番号を白で隠してから、太く大きく描き直す =====
(() => {
  // 1) 既存番号を「白帯」で隠す（0フレットも含めて左に広げる & 縁取り防止）
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.shadowColor = 'rgba(0,0,0,0)';
  ctx.lineWidth = 0;
  ctx.strokeStyle = 'rgba(0,0,0,0)';
  ctx.fillStyle = '#ffffff'; // PDFの地色が白
  const fretW   = g.fbW / frets;
  const extraL  = Math.round(fretW * 0.6);                 // 左に少し余裕
  const wipeH   = Math.round(g.fbH * 0.03);                // 帯の高さ（調整可）
  const wipeY = g.fbY + g.fbH + Math.round(g.fbH * 0.01);    // 少し下にずらす（指板より下に白帯を置く）
  const overscan = 2;                                      // 周囲に2px余分に塗る
  ctx.fillRect(
    g.baseX - extraL - overscan,
    wipeY - overscan,
    g.fbW + extraL + overscan * 2,
    wipeH + overscan * 2
  );
  ctx.restore();

  // 2) 大きい番号を上から描き直す
  const FRET_FONT_SCALE = 0.6;                             // 好みで 1.2〜2.0
  const fontPx = Math.round(g.fbH * 0.10 * FRET_FONT_SCALE);
  ctx.font = `700 ${fontPx}px system-ui`;
  ctx.fillStyle = '#000000';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  const y = g.fbY + g.fbH + Math.round(fontPx * 0.10);     // 指板の少し下
  // 0〜frets を等間隔で再配置（0フレットはナット左側）
  for (let f = 0; f <= frets; f++) {
    const cx = (f === 0)
      ? g.baseX - fretW / 2
      : g.baseX + fretW * (f - 0.5);
    ctx.fillText(String(f), cx, y);
  }
})();
    // スケール計算（既存と同じ）
    const {intervals, degrees} = SCALES[scaleName];
    const pcs = new Set(intervals.map(i => (root + i) % 12));
    const degreeMap = new Map(); intervals.forEach((i, idx)=> degreeMap.set((root + i) % 12, degrees[idx]));
 const NOTE_RADIUS_SCALE = 1.8; // 好みで 1.1〜1.6 などに
 const r = getNoteRadius() * NOTE_RADIUS_SCALE;

    // 音符を描画（非表示状態も反映）
    for(let s=0; s<STRINGS; s++){
      const openPc = N_SHARP.indexOf(TUNING[s]);
      const cy = g.fbY + g.fbH * (s+0.5)/STRINGS;
      const pc0 = openPc % 12;
      const k0 = `${s}:0`;
      const interval0 = (pc0 - root + 12) % 12;
      if (!hiddenMap[mapKey].has(k0) && pcs.has(pc0) && (!chordTonesOnly || isChordToneInterval(interval0))){
        drawNote(ctx, g.openCx, cy, r, pc0, root, degreeMap.get(pc0), labelMode, keySel.value, LightStyle);
      }
      for(let f=1; f<=frets; f++){
        const prevX = g.baseX + g.fbW * ((f-1)/frets);
        const thisX = g.baseX + g.fbW * (f/frets);
        const cx = (prevX + thisX)/2;
        const pc = (openPc + f) % 12;
        const k = `${s}:${f}`;
        const interval = (pc - root + 12) % 12;
      if (!hiddenMap[mapKey].has(k) && pcs.has(pc) && (!chordTonesOnly || isChordToneInterval(interval))){
          drawNote(ctx, cx, cy, r, pc, root, degreeMap.get(pc), labelMode, keySel.value, LightStyle);
        }
      }
    }

    if (typeof dpr!=='undefined') dpr = prevDpr;
    return off;
  }

  const off = document.createElement('canvas');
  off.width = outW;
  off.height = totalH;
 const ctx = off.getContext('2d');
 ctx.clearRect(0, 0, off.width, off.height);
 // 背景を完全な白で塗って透明を無くす
 ctx.save();
 ctx.fillStyle = '#ffffff';
 ctx.fillRect(0, 0, off.width, off.height);
 ctx.restore();

  // タイトル（黒）＋メタ（グレー）※メタは getMetaLine() を使う現行仕様のまま
  ctx.fillStyle = '#000000';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = `700 ${titleFontPx}px system-ui`;
  ctx.fillText(getPresetTitle(), titlePad, titlePad);
  ctx.font = `500 ${metaFontPx}px system-ui`;
  ctx.fillStyle = '#333333';
  ctx.fillText(getMetaLine(), titlePad, titlePad + titleFontPx + Math.round(metaFontPx * 0.4));

  // 各キャンバスをライト配色で再描画して貼り付け（＋ 小見出し）
  let yPos = titleAreaH;
  list.forEach((src, i) => {
    if (i > 0) {
      ctx.font = `600 ${subFontPx}px system-ui`;
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(posTitles[i-1] || `ポジション${i}`, Math.round(outW * 0.01), yPos);
      yPos += (subFontPx + subPad);
    }

    const mapKey = (i===0) ? 'main' : ids[i-1]; // 上段は 'main'、以下は各ID
    const lightCanvas = renderLightSnapshot(outW, scaledHeights[i], mapKey);
    ctx.drawImage(lightCanvas, 0, yPos);
    yPos += scaledHeights[i];
    if (i < list.length - 1) yPos += gap;
  });

  return off;
}

  function exportPDF() {
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) { alert('PDFライブラリ（jsPDF）が読み込めていません'); return; }

    const composed = composeExportCanvas();

    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    const m = PAGE_MM.margin;
    const contentW = PAGE_MM.w - m * 2;
    const contentH = PAGE_MM.h - m * 2;

    const imgWmm = contentW;
    const imgHmm = (contentW * composed.height) / composed.width;
    // 高さが足りなければ等比で縮小 → 1ページに収める
    const scale = Math.min(1, contentH / imgHmm);
    const drawW = imgWmm * scale;
    const drawH = imgHmm * scale;
    const x = m + (contentW - drawW) / 2;
    const y = m + (contentH - drawH) / 2;

    const dataURL = composed.toDataURL('image/png');
    doc.addImage(dataURL, 'PNG', x, y, drawW, drawH, undefined, 'FAST');

    const name = getPresetTitle().replace(/[\\/:*?"<>|]/g, '_') || 'export';
    doc.save(`${name}.pdf`);
  }

  // 既存ボタンにだけハンドラを追加（DOM/CSSは一切変更しない）
  const btn = document.getElementById('btnExportPdf');
  if (btn) btn.addEventListener('click', exportPDF);
})();
</script>


</body>
</html>
